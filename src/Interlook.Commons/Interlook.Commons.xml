<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Interlook.Commons</name>
    </assembly>
    <members>
        <member name="T:Interlook.Collections.CompositeObservableEnumerable`1">
            <summary>
            Class for a enumerator, which merges several enumerators by relaying their change events,
            as they implement <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>
            </summary>
            <typeparam name="T">The type of elements of all the contained enumerators.</typeparam>
        </member>
        <member name="P:Interlook.Collections.CompositeObservableEnumerable`1.Count">
            <summary>
            The total number of elements in all included enumerators.
            </summary>
        </member>
        <member name="M:Interlook.Collections.CompositeObservableEnumerable`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Collections.CompositeObservableEnumerable`1" /> class.
            </summary>
        </member>
        <member name="M:Interlook.Collections.CompositeObservableEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Collections.CompositeObservableEnumerable`1" /> class
            with a given sequence to add.
            </summary>
            <param name="sequenceToAdd">The sequence to add.</param>
        </member>
        <member name="M:Interlook.Collections.CompositeObservableEnumerable`1.AddEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds an enumerator.
            </summary>
            <param name="sequenceToAdd">The sequence to add.</param>
        </member>
        <member name="M:Interlook.Collections.CompositeObservableEnumerable`1.Contains(`0)">
            <summary>
            Determines whether any of the underlying enumerators contains an specified element.
            </summary>
            <param name="item">The element to check for.</param>
            <returns><c>true</c>, if an underlying enumerator contains the element.</returns>
        </member>
        <member name="M:Interlook.Collections.CompositeObservableEnumerable`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the total content of all underlying enumerators to an array.
            </summary>
            <param name="array">The target array.</param>
            <param name="arrayIndex">Index in <c>array</c> at which the copying begins.</param>
        </member>
        <member name="M:Interlook.Collections.CompositeObservableEnumerable`1.GetEnumerator">
            <summary>
            Returns the enumerator over all underlying enumerators.
            </summary>
        </member>
        <member name="T:Interlook.Collections.NullEntryDictionary`2">
            <summary>
            Dictionary, which always contains a value for <c>null</c> as key. 
            This <c>null</c>-value will always be iterated at first place.
            </summary>
            <typeparam name="TKey">Datatype of the key.</typeparam>
            <typeparam name="TValue">Datatype of the value.</typeparam>
        </member>
        <member name="P:Interlook.Collections.NullEntryDictionary`2.NullEntryValue">
            <summary>
            The Value for the <c>null</c>-key
            </summary>
        </member>
        <member name="P:Interlook.Collections.NullEntryDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Item(`0)">
            <summary>
            Gets or sets the <typeparamref name="TValue"/> with the specified key.
            </summary>
            <value>
            The value for the key (including <c>null</c>).
            </value>
            <param name="key">The key.</param>
            <returns>The value for the key.</returns>
        </member>
        <member name="M:Interlook.Collections.NullEntryDictionary`2.WithNullEntryValue(`1)">
            <summary>
            Sets the <c>null</c>-value for this dictionary in fluent API.
            </summary>
            <param name="nullValue">The value for the <c>null</c>-key.</param>
            <returns>This instance.</returns>
        </member>
        <member name="T:Interlook.Collections.NullEntryEnumerator`2">
            <summary>
            Helper enumerator, which ensures, that the <c>null</c>-value is always listed
            in first place.
            </summary>
            <typeparam name="TKey">Datatype of the key.</typeparam>
            <typeparam name="TValue">Datataype of the value.</typeparam>
        </member>
        <member name="M:Interlook.Collections.NullEntryEnumerator`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},`1,System.Func{System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{`0,`1}}})">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Collections.NullEntryEnumerator`2" /> struct.
            </summary>
            <param name="dictionary">The dictionary.</param>
            <param name="nullValue">The null value.</param>
            <param name="baseEnumeratorFactoryMethod">The base enumerator factory method.</param>
        </member>
        <member name="P:Interlook.Collections.NullEntryEnumerator`2.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <value>
            The element in the collection at the current position of the enumerator.
            </value>
        </member>
        <member name="M:Interlook.Collections.NullEntryEnumerator`2.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
             <c>true</c> if the enumerator was successfully advanced to the next element; <c>false</c> if
             the enumerator has passed the end of the collection.</returns>
             <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created.</exception>
        </member>
        <member name="M:Interlook.Collections.NullEntryEnumerator`2.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the sequence.
            </summary>
        </member>
        <member name="M:Interlook.Collections.NullEntryEnumerator`2.Dispose">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
        </member>
        <member name="T:Interlook.Collections.NullEntryObservableDictionary0`2">
            <summary>
            Dictionary, which always contains a value for <c>null</c> as key. 
            This <c>null</c>-value will always be iterated at first place.
            This dictionary derived from <see cref="T:Interlook.Collections.ObservableDictionary`2"/> and therefore
            implements the <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/>-interface
            </summary>
            <typeparam name="TKey">Type of key element</typeparam>
            <typeparam name="TValue">Type of value element</typeparam>
        </member>
        <member name="P:Interlook.Collections.NullEntryObservableDictionary0`2.NullEntryValue">
            <summary>
            The Value for the <c>null</c>-key
            </summary>
        </member>
        <member name="P:Interlook.Collections.NullEntryObservableDictionary0`2.Item(`0)">
            <summary>
            Gets or sets the <typeparamref name="TValue"/> with the specified key.
            </summary>
            <value>
            The value for the key (including <c>null</c>).
            </value>
            <param name="key">The key.</param>
            <returns>The value for the key.</returns>
        </member>
        <member name="T:Interlook.Collections.ObservableDictionary`2">
            <summary>
            A dictionary implementing <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> and <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            </summary>
            <typeparam name="TKey">Type of key element</typeparam>
            <typeparam name="TValue">Type of value element</typeparam>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the dictionary.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the dictionary  contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <returns>
            	<c>true</c>, if the dictionary contains an element with that key; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="P:Interlook.Collections.ObservableDictionary`2.Keys">
            <summary>
             Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the dictionary.
            </summary>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the dictionary.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns><c>true</c> if the element is successfully removed; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            No Exception is thrown if no element exists for the given key.
            </summary>
            <param name="key">The key whose value to get.</param>
            <param name="value">
            When this method returns, the value associated with the specified key, if
            the key is found; otherwise, the default value for the type of the value
            parameter. This parameter is passed uninitialized.
            </param>
            <returns><c>true</c> if an element for this key was found in the dictionary and its value stored in <c>value</c>.</returns>
        </member>
        <member name="P:Interlook.Collections.ObservableDictionary`2.Values">
            <summary>
             Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values int the dictionary.
            </summary>
        </member>
        <member name="P:Interlook.Collections.ObservableDictionary`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <param name="key">The key of the element to get or set.</param>
            <value>The element with the specified key.</value>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item.
            </summary>
            <param name="item">The new item.</param>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.Clear">
            <summary>
            Removes all items of the dictionary.
            </summary>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether this instance contains the object.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the dictionary into an array, 
            starting at an particular index
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination 
            of the elements from this dictionary.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="P:Interlook.Collections.ObservableDictionary`2.Count">
            <summary>
             Gets the number of elements contained in the dictionary.
            </summary>
        </member>
        <member name="P:Interlook.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>
            Returns whether the dictionary is readonly or can be manipulated.
            </summary>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the first occurrence of a specific object from the dictionary.
            </summary>
            <param name="item">The object to remove.</param>
            <returns><c>true</c> if item was successfully removed; otherwise <c>false</c></returns>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator for iterating through the dictionary.
            </summary>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the dictionary.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the dictionary
            </returns>
        </member>
        <member name="E:Interlook.Collections.ObservableDictionary`2.CollectionChanged">
            <summary>
            Occurs when the collection changes.
            </summary>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
            Raises the <see cref="E:collectionChanged"/> event.
            </summary>
            <param name="e">Event arguments.</param>
        </member>
        <member name="E:Interlook.Collections.ObservableDictionary`2.PropertyChanged">
            <summary>
             Occurs when a property value changes.
            </summary>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.OnPropertyChanged(System.String)">
            <summary>
            Raising the <c>propertyChanged</c> event.
            </summary>
            <param name="propertyName">Name of the changed property.</param>
        </member>
        <member name="M:Interlook.Collections.ObservableDictionary`2.AddRange(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Adds several items at once.
            </summary>
            <param name="items">Dictionary, containing the items to add.</param>
        </member>
        <member name="T:Interlook.Components.AsyncChainOfResponsibility`1">
            <summary>
            A chain-of-responsibility implementation as a queue of delegates.
            An item is passed on for processing until a handler signals,
            that it has processed the item.
            Handlers can optionally be added with priorities, but not placed
            in a certain position in the chain.
            </summary>
            <typeparam name = "TItem">Data type to be processed</typeparam>
        </member>
        <member name="P:Interlook.Components.AsyncChainOfResponsibility`1.ErrorHandling">
            <summary>
            Specifies how to handle exceptions in handlers when processing.
            </summary>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Components.AsyncChainOfResponsibility`1"/> class.
            </summary>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`1.AddHandler(Interlook.Components.AsyncChainOfResponsibilityHandler{`0},Interlook.Components.Priority)">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler">The handler to be added. </param>
            <param name = "priority">The priority of the handler to add. </param>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`1.AddHandler(Interlook.Components.AsyncChainOfResponsibilityHandler{`0})">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler">The handler to be added. </param>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`1.ProcessAsync(`0)">
            <summary>
            Passes an item to the chain for processing.
            </summary>
            <param name = "itemToProcess">The item to process. </param>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`1.ProcessAsync(`0,System.Action{System.Boolean})">
            <summary>
            Passes an item to the chain for processing.
            </summary>
            <param name = "itemToProcess">The item to process. </param>
            <param name="resultCallback">Optional. Callback, invoked with processed-state (<c>true/false</c>) when chain has been finished without errors.</param>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`1.ProcessAsync(`0,System.Action{System.Boolean},System.Action{System.Exception})">
            <summary>
            Passes an item to the chain for processing.
            </summary>
            <param name = "itemToProcess">The item to process. </param>
            <param name="resultCallback">Optional. Callback, invoked with processed-state (<c>true/false</c>) when chain has been finished without errors.</param>
            <param name="errorCallback">Optional. Callback, to be invoked if an exception occurs (if <see cref="T:Interlook.Components.ExceptionHandling"/> is set accordningly),
            independent of <c>resultCallback</c>.</param>
        </member>
        <member name="T:Interlook.Components.AsyncChainOfResponsibilityHandler`1">
            <summary>
            Async Handler/Processor for a Chain-Of-Responsibility.
            Returns <c>true</c> if it was responsible for processing.
            </summary>
            <typeparam name = "TItem"> Data type of the item to be processed. </typeparam>
            <param name = "item"> The item to process. </param>
            <returns> <c> true </c> if the item has been processed and the chain can be terminated. </returns>
        </member>
        <member name="T:Interlook.Components.AsyncChainOfResponsibility`2">
            <summary>
            A chain-of-responsibility implementation as a queue of delegates.
            An item is passed on for processing until a handler signals,
            that it has processed the item.
            Handlers can optionally be added with priorities, but not placed
            in a certain position in the chain.
            </summary>
            <typeparam name = "TItem">Data type to be processed</typeparam>
            <typeparam name="TResult">Data type of the handlers' result.</typeparam>
        </member>
        <member name="P:Interlook.Components.AsyncChainOfResponsibility`2.ErrorHandling">
            <summary>
            Specifies how to handle exceptions in handlers when processing.
            </summary>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Components.AsyncChainOfResponsibility`1"/> class.
            </summary>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`2.AddHandler(Interlook.Components.AsyncChainOfResponsibilityResultHandler{`0,`1},Interlook.Components.Priority)">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler">The handler to be added. </param>
            <param name = "priority">The priority of the handler to add. </param>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`2.AddHandler(Interlook.Components.AsyncChainOfResponsibilityResultHandler{`0,`1})">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler">The handler to be added. </param>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`2.ProcessAsync(`0,System.Action{`1})">
            <summary>
            Passes an item to the chain for processing.
            </summary>
            <param name = "itemToProcess">The item to process. </param>
            <param name="resultCallback">Callback, invoked with processed-state (<c>true/false</c>) when chain has been finished without errors. Must not be <c>null</c></param>
        </member>
        <member name="M:Interlook.Components.AsyncChainOfResponsibility`2.ProcessAsync(`0,System.Action{`1},System.Action{System.Exception})">
            <summary>
            Passes an item to the chain for processing.
            </summary>
            <param name = "itemToProcess">The item to process. </param>
            <param name="resultCallback">Callback, invoked with processed-state (<c>true/false</c>) when chain has been finished without errors. Must not be <c>null</c></param>
            <param name="errorCallback">Optional. Callback, to be invoked if an exception occurs (if <see cref="T:Interlook.Components.ExceptionHandling"/> is set accordningly),
            independent of <c>resultCallback</c>.</param>
        </member>
        <member name="T:Interlook.Components.AsyncChainOfResponsibilityResultHandler`2">
            <summary>
            Async handler / processor for a chain-of-responsibility with return value.
            Returns a <see cref = "T:Interlook.Components.MethodResult`1" /> in which the status of the processing (responsibility)
            and eventually the result is packed.
            </summary>
            <typeparam name = "TItem">The type of the item.</typeparam>
            <typeparam name = "TResult">The type of the result.</typeparam>
            <param name = "item">The item to process.</param>
            <returns>
            A <see cref = "T:Interlook.Components.MethodResult`1"/> which contains the status of the processing
            in the <c>ReturnCode</c> (responsible, not responsible) and possibly the result in <c> Result </c>.
            </returns>
        </member>
        <member name="T:Interlook.Components.ChainOfResponsibility`1">
            <summary>
            A chain-of-responsibility implementation as a queue of delegates.
            An item is passed on for processing until a handler signals,
            that it has processed the item.
            Handlers can optionally be added with priorities, but not placed
            in a certain position in the chain.
            </summary>
            <typeparam name = "TItem">Data type to be processed</typeparam>
        </member>
        <member name="P:Interlook.Components.ChainOfResponsibility`1.ExceptionHandling">
            <summary>
            Specifies how to handle exceptions in handlers when processing.
            </summary>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Components.ChainOfResponsibility`1"/> class.
            </summary>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`1.AddHandler(Interlook.Components.ChainOfResponsibilityHandler{`0},Interlook.Components.Priority)">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler"> The handler to be added. </param>
            <param name = "priority"> The priority of the handler to add. </param>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`1.AddHandler(Interlook.Components.ChainOfResponsibilityHandler{`0})">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler"> The handler to be added. </param>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`1.Process(`0)">
            <summary>
            Passes an item to the chain for processing.
            </summary>
            <param name = "itemToProcess"> The item to process. </param>
            <returns> <c> true </c> if the item has been processed, otherwise <c> false </c>. </returns>
        </member>
        <member name="T:Interlook.Components.ChainOfResponsibilityHandler`1">
            <summary>
            Handler/Processor for a Chain-Of-Responsibility.
            Returns <c> true </c> if it was responsible for processing.
            </summary>
            <typeparam name = "TItem"> Data type of the item to be processed. </typeparam>
            <param name = "item"> The item to process. </param>
            <returns> <c> true </c> if the item has been processed and the chain can be terminated. </returns>
        </member>
        <member name="T:Interlook.Components.ExceptionHandling">
            <summary>
            Enumeration of modes for dealing with exceptions in handlers
            </summary>
        </member>
        <member name="F:Interlook.Components.ExceptionHandling.IgnoreAndContinue">
            <summary>
            Ignore exception and continue with next handler.
            </summary>
        </member>
        <member name="F:Interlook.Components.ExceptionHandling.CancelProcessing">
            <summary>
            Abort processing and return as unhandled.
            </summary>
        </member>
        <member name="F:Interlook.Components.ExceptionHandling.ThrowException">
            <summary>
            Processing is aborted by an exception.
            </summary>
        </member>
        <member name="T:Interlook.Components.Priority">
            <summary>
            Enumeration of processing priorities
            </summary>
        </member>
        <member name="F:Interlook.Components.Priority.High">
            <summary>
            Highest
            </summary>
        </member>
        <member name="F:Interlook.Components.Priority.AboveNormal">
            <summary>
            Higher
            </summary>
        </member>
        <member name="F:Interlook.Components.Priority.Normal">
            <summary>
            Normal
            </summary>
        </member>
        <member name="F:Interlook.Components.Priority.BelowNormal">
            <summary>
            Lower
            </summary>
        </member>
        <member name="F:Interlook.Components.Priority.Low">
            <summary>
            Lowest
            </summary>
        </member>
        <member name="T:Interlook.Components.ChainOfResponsibilityResultHandler`2">
            <summary>
            handler / processor for a chain-of-responsibility with return value.
            Returns a <see cref = "T:Interlook.Components.MethodResult`1" /> in which the status of the processing (responsibility)
            and eventually the result is packed.
            </summary>
            <typeparam name = "TItem">The type of the item.</typeparam>
            <typeparam name = "TResult">The type of the result.</typeparam>
            <param name = "item">The item to process.</param>
            <returns>
            A <see cref = "T:Interlook.Components.MethodResult`1"/> which contains the status of the processing
            in the <c>ReturnCode</c> (responsible, not responsible) and possibly the result in <c> Result </c>.
            </returns>
        </member>
        <member name="T:Interlook.Components.ChainOfResponsibility`2">
            <summary>
            A chain-of-responsibility implementation as a queue of delegates.
            An item is passed on for processing until a handler signals,
            that it has processed the item.
            Handlers can optionally be added with priorities, but not placed
            in a certain position in the chain.
            </summary>
            <typeparam name = "TItem">The type of the item. </typeparam>
            <typeparam name = "TResult">The type of the result. </typeparam>
        </member>
        <member name="P:Interlook.Components.ChainOfResponsibility`2.ExceptionHandling">
            <summary>
            Specifies how to handle exceptions in handlers when processing.
            </summary>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Components.ChainOfResponsibility`2"/> class.
            </summary>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`2.AddHandler(Interlook.Components.ChainOfResponsibilityResultHandler{`0,`1},Interlook.Components.Priority)">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler"> The handler to be added. </param>
            <param name = "priority"> The priority of the handler to add. </param>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`2.AddHandler(Interlook.Components.ChainOfResponsibilityResultHandler{`0,`1})">
            <summary>
            Adds an processor (handler) to the chain.
            </summary>
            <param name = "handler"> The handler to be added. </param>
        </member>
        <member name="M:Interlook.Components.ChainOfResponsibility`2.Process(`0)">
            <summary>
            Passes an item to the chain for processing.
            </summary>
            <param name = "itemToProcess"> The item to process. </param>
            <returns> The result object or <c> default (TResult) </c> if no handler was responsible. </returns>
        </member>
        <member name="T:Interlook.Components.ConcreteDelegateComparer`1">
            <summary>
            Variant of <see cref="T:Interlook.Components.DelegateComparer`1"/>, which only uses the equality delegate,
            if both arguments are not null (otherwise <c>false</c> is returned) 
            and are no equal references (results in <c>true</c>).
            Furthermore the hashing delegate is only called for non null objects and
            zero returned instead.
            </summary>
            <typeparam name="T">Type of the objects, that are to be compared.</typeparam>
        </member>
        <member name="M:Interlook.Components.ConcreteDelegateComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Components.ConcreteDelegateComparer`1"/> class.
            </summary>
            <param name="equalsFunc">function, that determines the equality of two non-<c>null</c> objects of type <c>T</c>.</param>
            <param name="hashFunc">Function, that calculates the hashcode for a <c>T</c> object, that is not null.</param>
        </member>
        <member name="M:Interlook.Components.ConcreteDelegateComparer`1.Equals(`0,`0)">
            <summary>
            Determines, if two given objects of type <c>T</c> are equal.
            </summary>
            <param name="x">The first object.</param>
            <param name="y">The object to compare.</param>
            <returns>
              <c>true</c>, if the given objects are equal, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Interlook.Components.ConcreteDelegateComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <param name="obj">The object.</param>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Interlook.Components.DelegateComparer`1">
            <summary>
            Implementation of the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> interface for comparers,
            that are defined via delegate functions.
            </summary>
            <typeparam name="T">Type of the objects, that are to be compared.</typeparam>
        </member>
        <member name="M:Interlook.Components.DelegateComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Components.DelegateComparer`1"/> class.
            </summary>
            <param name="equalsFunc">function, that determines the equality of two <c>T</c> objects.</param>
            <param name="hashFunc">Function, that calculates the hashcode for a <c>T</c> object.</param>
        </member>
        <member name="M:Interlook.Components.DelegateComparer`1.Equals(`0,`0)">
            <summary>
            Determines, if two given objects of type <c>T</c> are equal.
            </summary>
            <param name="x">The first object.</param>
            <param name="y">The object to compare.</param>
            <returns><c>true</c>, if the given objects are equal, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Interlook.Components.DelegateComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <param name="obj">The object.</param>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Interlook.Components.DelegateDisposableToken">
            <summary>
            An implementation of <see cref="T:Interlook.Components.DisposableToken"/> that executes
            a delegate, when token object is being disposed.
            </summary>
        </member>
        <member name="M:Interlook.Components.DelegateDisposableToken.#ctor(System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Components.DelegateDisposableToken"/> class.
            </summary>
            <param name="action">The action to perform at disposal.</param>
        </member>
        <member name="T:Interlook.Components.DisposableToken">
            <summary>
            Baseclass for token objects, that perform an action, when they're disposed.
            Useful for 'terminating actions' in <c>using</c>-statements.
            </summary>
        </member>
        <member name="M:Interlook.Components.DisposableToken.DoDisposeAction">
            <summary>
            Action, that is performed, when object is disposing
            just before <see cref="M:System.GC.SuppressFinalize(System.Object)"/> is called.
            </summary>
        </member>
        <member name="M:Interlook.Components.DisposableToken.Equals(Interlook.Components.DisposableToken,Interlook.Components.DisposableToken)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type to compare.</param>
            <param name="y">The second object of type to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:Interlook.Components.DisposableToken.GetHashCode(Interlook.Components.DisposableToken)">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <param name="obj">The object.</param>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:Interlook.Components.DisposableToken.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Interlook.Components.DisposableToken.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:Interlook.Components.DisposableToken.Equals(Interlook.Components.DisposableToken)">
            <summary>
            Determines whether the specified <see cref="T:Interlook.Components.DisposableToken" />, is equal to this instance.
            </summary>
            <param name="other">The other.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Components.MethodResult`1">
            <summary>
            Generic class to encapsulate a method result, enriched with success(error information.
            </summary>
        </member>
        <member name="P:Interlook.Components.MethodResult`1.Result">
            <summary>
            The actual result.
            </summary>
        </member>
        <member name="P:Interlook.Components.MethodResult`1.ReturnMessage">
            <summary>
            An error message.
            </summary>
        </member>
        <member name="P:Interlook.Components.MethodResult`1.ReturnCode">
            <summary>
            Code to qualify the type of result (error, success)
            </summary>
        </member>
        <member name="P:Interlook.Components.MethodResult`1.IsSuccess">
            <summary>
            Returns, if the the method result reflects an successful invocation
            </summary>
        </member>
        <member name="M:Interlook.Components.MethodResult`1.ThrowOnError">
            <summary>
            Throws an exception, if and only if the method result was an error
            </summary>
        </member>
        <member name="M:Interlook.Components.MethodResult`1.CreateSuccess(`0)">
            <summary>
            Creates a success result with content.
            </summary>
            <param name="result">The actual result.</param>
            <returns>A new instance of the closed generic result with data.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult`1.CreateFailed(System.Int32)">
            <summary>
            Creates a failure result with error code.
            </summary>
            <param name="errorCode">Error code.</param>
            <returns>A new instance of the closed generic result with error code.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult`1.CreateFailed(System.String)">
            <summary>
            Creates a failure result with error message.
            </summary>
            <param name="errorMessage">The error message.</param>
            <returns>A new instance of the closed generic result with error message.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult`1.CreateFailed(System.Exception)">
            <summary>
            Creates a failure result with specified exception.
            </summary>
            <param name="ex">The exception to throw on <see cref="M:Interlook.Components.MethodResult`1.ThrowOnError"/>.</param>
            <returns>A new instance of the closed generic result with specified exception.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult`1.CreateFailed(System.Int32,System.String)">
            <summary>
            Creates a failure result with error code and message.
            </summary>
            <param name="errorCode">The error code.</param>
            <param name="errorMessage">The error message.</param>
            <returns>A new instance of the closed generic result with error code and message.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult`1.CreateFailed(System.Int32,System.Exception)">
            <summary>
            Creates a failure result with error code and specified exception.
            </summary>
            <param name="errorCode">The error code.</param>
            <param name="ex">The exception to throw on <see cref="M:Interlook.Components.MethodResult`1.ThrowOnError"/>.</param>
            <returns>A new instance of the closed generic result with error code and exception.</returns>
        </member>
        <member name="T:Interlook.Components.MethodResult">
            <summary>
            Class to encapsulate a method result, enriched with success(error information.
            </summary>
        </member>
        <member name="P:Interlook.Components.MethodResult.Result">
            <summary>
            The actual result.
            </summary>
        </member>
        <member name="P:Interlook.Components.MethodResult.ReturnMessage">
            <summary>
            An error message.
            </summary>
        </member>
        <member name="P:Interlook.Components.MethodResult.ReturnCode">
            <summary>
            Code to qualify the type of result (error, success)
            </summary>
        </member>
        <member name="M:Interlook.Components.MethodResult.ThrowOnError">
            <summary>
            Throws an exception, if and only if the method result was an error
            </summary>
        </member>
        <member name="M:Interlook.Components.MethodResult.CreateSuccess">
            <summary>
            Creates a success result without content.
            </summary>
            <returns>A new instance of the closed generic result without data.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult.CreateSuccess(System.Object)">
            <summary>
            Creates a success result with content.
            </summary>
            <param name="result">The actual result.</param>
            <returns>A new instance of the result with data.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult.CreateFailed(System.Int32)">
            <summary>
            Creates a failure result with error code.
            </summary>
            <param name="errorCode">Error code.</param>
            <returns>A new instance of the result with error code.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult.CreateFailed(System.String)">
            <summary>
            Creates a failure result with error message.
            </summary>
            <param name="errorMessage">The error message.</param>
            <returns>A new instance of the result with error message.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult.CreateFailed(System.Exception)">
            <summary>
            Creates a failure result with specified exception.
            </summary>
            <param name="ex">The exception to throw on <see cref="M:Interlook.Components.MethodResult.ThrowOnError"/>.</param>
            <returns>A new instance of the result with specified exception.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult.CreateFailed(System.Int32,System.String)">
            <summary>
            Creates a failure result with error code and message.
            </summary>
            <param name="errorCode">The error code.</param>
            <param name="errorMessage">The error message.</param>
            <returns>A new instance of the result with error code and message.</returns>
        </member>
        <member name="M:Interlook.Components.MethodResult.CreateFailed(System.Int32,System.Exception)">
            <summary>
            Creates a failure result with error code and specified exception.
            </summary>
            <param name="errorCode">The error code.</param>
            <param name="ex">The exception to throw on <see cref="M:Interlook.Components.MethodResult.ThrowOnError"/>.</param>
            <returns>A new instance of the closed generic result with error code and exception.</returns>
        </member>
        <member name="T:Interlook.Eventing.EventArgs`1">
            <summary>
            Simple class for event args containing a typed payload.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Interlook.Eventing.EventArgs`1.Data">
            <summary>
            Actual payload of the event args.
            </summary>
        </member>
        <member name="M:Interlook.Eventing.EventArgs`1.#ctor(`0)">
            <summary>
            Creates an generic event args object.
            </summary>
            <param name="data">Payload of the event args.</param>
        </member>
        <member name="T:Interlook.Eventing.EventBus">
            <summary>
            Default implementation of the <see cref="T:Interlook.Eventing.IEventBus"/> and <see cref="T:Interlook.Eventing.IEventBusEx"/> interfaces.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEvent">
            <summary>
            Marker interface, events must implement.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEventBus">
            <summary>
            Interface, that provides methods for publishing to events on an event bus.
            </summary>
        </member>
        <member name="M:Interlook.Eventing.IEventBus.Publish``1(``0)">
            <summary>
            Publishes an event on the event bus.
            </summary>
            <typeparam name="TEvent">Type of the event, that is to be published.</typeparam>
            <param name="ev">The actual event object to publish.</param>
        </member>
        <member name="T:Interlook.Eventing.IEventBusEx">
            <summary>
            Interface, that combines the interface for event publishing and the extended event source, which supports
            in addition to subscribing to events the usage of weak delegates for subscriptions.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEventHandlerFor`1">
            <summary>
            Generic Interface for event handlers.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEventPublisherTransaction">
            <summary>
            Interface, that provides methods for buffering events to finally commit or discard them. Makes it thus possible,
            to collect a bunch of events first an publish them later as a one-block.
            </summary>
        </member>
        <member name="M:Interlook.Eventing.IEventPublisherTransaction.PublishAllEvents">
            <summary>
            Publishes all events, that has been published into buffer so far.
            </summary>
        </member>
        <member name="M:Interlook.Eventing.IEventPublisherTransaction.DiscardAllEvents">
            <summary>
            Discards all bufferend events.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEventSource">
            <summary>
            Interface, that provides methods for subscribing to events on an event bus.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEventSourceEx">
            <summary>
            Interface, that provides additional methods for subscribing to events on an event bus, that provide support for
            weak references, so registered handlers arent be blocked from garbage collection.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEventSubscription">
            <summary>
            Base Interface for event subscriptions.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.IEventTransactionSupport">
            <summary>
            Interface, that provides creation of buffers/transactions for events.
            </summary>
        </member>
        <member name="M:Interlook.Eventing.IEventTransactionSupport.CreateTransactionForLocalThread">
            <summary>
            Creates an object, implementing <see cref="T:Interlook.Eventing.IEventPublisherTransaction"/> for support of buffering events.
            </summary>
            <returns>A new transaction object implementing <see cref="T:Interlook.Eventing.IEventPublisherTransaction"/>.</returns>
        </member>
        <member name="T:Interlook.Eventing.IUnsubscribeToken">
            <summary>
            Interface to support unsubscribing of events.
            </summary>
        </member>
        <member name="T:Interlook.Eventing.UnsubscribeToken">
            <summary>
            Interface to support unsubscribing of events.
            </summary>
        </member>
        <member name="T:Interlook.Functional.FunctionalExtensions">
            <summary>
            Defines helper methods for functional programming
            </summary>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.AsFactoryFunc``1(``0)">
            <summary>
            Creates a function, returning the value/object.
            </summary>
            <typeparam name="T">Type of the value/object.</typeparam>
            <param name="value">A value.</param>
            <returns>A function, that returns the specified value.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.Flip``3(System.Func{``0,``1,``2})">
            <summary>
            Swaps the order of the arguments of a function with two arguments.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">A function, whose arguments are to be reversed in order.</param>
            <returns>A new function, executing the original function with reversed arguments.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.Flip``2(System.Action{``0,``1})">
            <summary>
            Swaps the order of the arguments of an action with two arguments.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <param name="action">An action, whose arguments are to be reversed in order.</param>
            <returns>A new action, executing the original action with reversed arguments.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.Compose``3(System.Func{``0,``1},System.Func{``1,``2})">
            <summary>
            Composition/chaining of two functions.
            </summary>
            <typeparam name="T1">Type of the input of the first function.</typeparam>
            <typeparam name="T2">Type of the result of the first function and the input of the second function.</typeparam>
            <typeparam name="T3">Type of the result of the second function.</typeparam>
            <param name="f">The first function.</param>
            <param name="g">The second function.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.LazyApply``2(System.Func{``0,``1},``0)">
            <summary>
            Creates a function, calling the given function
            with a specified value.
            </summary>
            <typeparam name="T1">Type of the function's parameter.</typeparam>
            <typeparam name="TResult">Type of the function's result.</typeparam>
            <param name="function">The function.</param>
            <param name="arg">The argument-value for the function.</param>
            <returns>A new function with reduced arity.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.PartialApply``3(System.Func{``0,``1,``2},``0)">
            <summary>
            Assigns a value to the first argument of the function
            and returns a new function with only one argument
            (originally the second one), thus reduced arity.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="arg">The argument-value to bind.</param>
            <returns>A new function with reduced arity.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.PartialApply``4(System.Func{``0,``1,``2,``3},``0)">
            <summary>
            Assigns a value to the first argument of the function
            and returns a new function with the remaining arguments.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="T3">Type of the third argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="arg">The argument-value to bind.</param>
            <returns>A new function with reduced arity.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.PartialApply``5(System.Func{``0,``1,``2,``3,``4},``0)">
            <summary>
            Assigns a value to the first argument of the function
            and returns a new function with the remaining arguments.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="T3">Type of the third argument</typeparam>
            <typeparam name="T4">Type of the third argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="arg">The argument-value to bind.</param>
            <returns>A new function with reduced arity.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.PartialApply``6(System.Func{``0,``1,``2,``3,``4,``5},``0)">
            <summary>
            Assigns a value to the first argument of the function
            and returns a new function with the remaining arguments.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="T3">Type of the third argument</typeparam>
            <typeparam name="T4">Type of the third argument</typeparam>
            <typeparam name="T5">Type of the third argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <param name="arg">The argument-value to bind.</param>
            <returns>A new function with reduced arity.</returns>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.Curry``3(System.Func{``0,``1,``2})">
            <summary>
            Returns a curry function of the function,
            meaning a function with the first original argument,
            returning a function for the second original argument.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <returns>The curry function.</returns>
            <example>
            // principle of currying in C# functions
            Func&lt;int, int, int&gt; f = (x, y, n) => (x + y) * n;
            var curried = f.Curry();
            
            var result1 = f(3, 2, 4);       // returns 20
            var result2 = curry(3)(2)(4)
            </example>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.Curry``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Returns a curry function of the function,
            meaning a function with the first original argument,
            returning a function for the second original argument.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="T3">Type of the third argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <returns>The curry function.</returns>
            <example>
            // principle of currying in C# functions
            Func&lt;int, int, int&gt; f = (x, y, n) => (x + y) * n;
            var curried = f.Curry();
            
            var result1 = f(3, 2, 4);       // returns 20
            var result2 = curry(3)(2)(4)
            </example>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.Curry``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Returns a curry function of the function,
            meaning a function with the first original argument,
            returning a function for the second original argument.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="T3">Type of the third argument</typeparam>
            <typeparam name="T4">Type of the third argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <returns>The curry function.</returns>
            <example>
            // principle of currying in C# functions
            Func&lt;int, int, int&gt; f = (x, y, n) => (x + y) * n;
            var curried = f.Curry();
            
            var result1 = f(3, 2, 4);       // returns 20
            var result2 = curry(3)(2)(4)
            </example>
        </member>
        <member name="M:Interlook.Functional.FunctionalExtensions.Curry``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            Returns a curry function of the function,
            meaning a function with the first original argument,
            returning a function for the second original argument.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument</typeparam>
            <typeparam name="T3">Type of the third argument</typeparam>
            <typeparam name="T4">Type of the third argument</typeparam>
            <typeparam name="T5">Type of the third argument</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="function">The function.</param>
            <returns>The curry function.</returns>
            <example>
            // principle of currying in C# functions
            Func&lt;int, int, int&gt; f = (x, y, n) => (x + y) * n;
            var curried = f.Curry();
            
            var result1 = f(3, 2, 4);       // returns 20
            var result2 = curry(3)(2)(4)
            </example>
        </member>
        <member name="T:Interlook.Monads.Either`2">
            <summary>
            Strict either monad, with instant execution, no deferred evaluation.
            </summary>
            <typeparam name="TLeft">Data type of 'Left' (Error)</typeparam>
            <typeparam name="TRight">Data type of 'Right' (Result)</typeparam>
        </member>
        <member name="P:Interlook.Monads.Either`2.IsLeft">
            <summary>
            Gets a value indicating whether this instance is in left state.
            </summary>
            <value>
              <c>true</c> if this instance is in left state; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Interlook.Monads.Either`2.IsRight">
            <summary>
            Gets a value indicating whether this instance is in right state.
            </summary>
            <value>
              <c>true</c> if this instance is in right state; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Interlook.Monads.Either`2.GetLeft">
            <summary>
            Gets the left value.
            </summary>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">If instance was not in left state.</exception>
        </member>
        <member name="M:Interlook.Monads.Either`2.GetRight">
            <summary>
            Gets the right value.
            </summary>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">If instance was not in right state.</exception>
        </member>
        <member name="M:Interlook.Monads.Either`2.GetLeftInternal">
            <summary>
            Returns, in overriding classes, the left value. 
            Throws an exception, if the instance is not in left state.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Either`2.GetRightInternal">
            <summary>
            Returns, in overriding classes, the right value.
            Throws an exception, if the instance is not in right state.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Either`2.BindInternal``1(System.Func{`1,Interlook.Monads.Either{`0,``0}})">
            <summary>
            Binds a function, in overriding classes.
            </summary>
            <typeparam name="TRightResult">The right type of the result.</typeparam>
            <param name="func">The function to bind.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.Right`2">
            <summary>
            Implements an either monad in right state
            </summary>
            <typeparam name="TLeft">The left data type.</typeparam>
            <typeparam name="TRight">The right data type.</typeparam>
            <seealso cref="T:Interlook.Monads.Either`2" />
        </member>
        <member name="P:Interlook.Monads.Right`2.IsLeft">
            <summary>
            Gets a value indicating whether this instance is in left state.
            </summary>
            <value>
            <c>true</c> if this instance is in left state; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Interlook.Monads.Right`2.Create(`1)">
            <summary>
            Static factory method.
            </summary>
            <param name="right">The right value.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Right`2.GetLeftInternal">
            <summary>
            Not supported for instances in right state.
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Interlook.Monads.Right`2.GetRightInternal">
            <summary>
            Gets the right value.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Right`2.#ctor(`1)">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Monads.Right`2"/> class.
            </summary>
            <param name="value">The right value.</param>
        </member>
        <member name="M:Interlook.Monads.Right`2.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Interlook.Monads.Right`2.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Right`2.BindInternal``1(System.Func{`1,Interlook.Monads.Either{`0,``0}})">
            <summary>
            Implementation for binding a function to the instance.
            </summary>
            <typeparam name="TRightResult">The right type of the result</typeparam>
            <param name="func">The function to bind.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="func"/> was <c>null</c>.</exception>
        </member>
        <member name="T:Interlook.Monads.Left`2">
            <summary>
            Implements an either monad in left state (generally: the failed state)
            </summary>
            <typeparam name="TLeft">The left data type.</typeparam>
            <typeparam name="TRight">The right data type.</typeparam>
            <seealso cref="T:Interlook.Monads.Either`2" />
        </member>
        <member name="P:Interlook.Monads.Left`2.IsLeft">
            <summary>
            Gets a value indicating whether this instance is in left state.
            </summary>
            <value>
            <c>true</c> if this instance is in left state; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Interlook.Monads.Left`2.Create(`0)">
            <summary>
            Static factory method.
            </summary>
            <param name="left">The left value.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Left`2.GetLeftInternal">
            <summary>
            Returns the left value.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Left`2.GetRightInternal">
            <summary>
            Not valid for instances in left state.
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Interlook.Monads.Left`2.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Monads.Left`2"/> class.
            </summary>
            <param name="value">The value left.</param>
        </member>
        <member name="M:Interlook.Monads.Left`2.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Interlook.Monads.Left`2.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Left`2.BindInternal``1(System.Func{`1,Interlook.Monads.Either{`0,``0}})">
            <summary>
            Does not actually bind the function, since the instance is in left state.
            Hence, a new <see cref="T:Interlook.Monads.Left`2"/> instance is returned.
            </summary>
            <typeparam name="TRightResult">The right type of the result.</typeparam>
            <param name="func">The function to bind.</param>
            <returns>A new <see cref="T:Interlook.Monads.Left`2"/> with the original left value.</returns>
        </member>
        <member name="T:Interlook.Monads.Either">
            <summary>
            Contains helper/extension methods for the either monad.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Either.Left``2(``0)">
            <summary>
            Creates a new <see cref="M:Interlook.Monads.Either.Left``2(``0)"/> instance
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="value">The left value.</param>
        </member>
        <member name="M:Interlook.Monads.Either.Right``2(``1)">
            <summary>
            Creates a new <see cref="M:Interlook.Monads.Either.Right``2(``1)"/> instance
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="value">The right value.</param>
        </member>
        <member name="M:Interlook.Monads.Either.Bind``3(Interlook.Monads.Either{``0,``1},System.Func{``1,Interlook.Monads.Either{``0,``2}})">
            <summary>
            Binds the specified function.
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRightSource">The right type of the specified either.</typeparam>
            <typeparam name="TRightResult">The righttype of the result.</typeparam>
            <param name="either">The either.</param>
            <param name="functionToBind">The function to bind.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/> or <paramref name="functionToBind"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Either.FailIf``2(Interlook.Monads.Either{``0,``1},System.Func{``1,System.Boolean},``0)">
            <summary>
            Switches to the left (failed) state under conditions, defined by a function.
            If that function results in <c>false</c>, nothing is altered.
            </summary>
            <typeparam name="TLeft">Left data type (Error)</typeparam>
            <typeparam name="TRight">Right data type (Result)</typeparam>
            <param name="either">Either-object</param>
            <param name="errorCondition">Error condition.</param>
            <param name="errorValue">Error value, assigned to left state if function fails.</param>
            <returns>
            Either-instance in the possibly changed state.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/> or <paramref name="errorCondition"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Either.SelectMany``4(Interlook.Monads.Either{``0,``1},System.Func{``1,Interlook.Monads.Either{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            For LINQ-Query-Support
            </summary>
            <typeparam name="TLeft">Left data type (Error)</typeparam>
            <typeparam name="TRight">Right data type (Result)</typeparam>
            <typeparam name="TSecond">The type of the second mapping function</typeparam>
            <typeparam name="TResult">Right data type (Result) of the result either monad.</typeparam>
            <param name="either">Either-object</param>
            <param name="func">The function.</param>
            <param name="select">The select function.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/>, <paramref name="func"/> or <paramref name="select"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Either.Select``3(Interlook.Monads.Either{``0,``1},System.Func{``1,``2})">
            <summary>
            For LINQ-Query support
            </summary>
            <typeparam name="TLeft">Left data type (Error)</typeparam>
            <typeparam name="TRight">Right data type (Result)</typeparam>
            <typeparam name="TResult">Right data type (Result) of the result either monad.</typeparam>
            <param name="either">Either-object</param>
            <param name="selector">The selector function.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/> or <paramref name="selector"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Either.Lefts``2(System.Collections.Generic.IEnumerable{Interlook.Monads.Either{``0,``1}})">
            <summary>
            Evaluates an enumerator of either monads and returns the
            error values of those in a left state.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <param name="source">Source enumerator of either monads.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="source"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Either.Rights``2(System.Collections.Generic.IEnumerable{Interlook.Monads.Either{``0,``1}})">
            <summary>
            Evaluates an enumerator of either monads and returns the
            right values of those in a right state.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <param name="source">Source enumerator of either monads.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="source"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Either.PartitionEithers``2(System.Collections.Generic.IEnumerable{Interlook.Monads.Either{``0,``1}})">
            <summary>
            Evaluates an enumerator of either monads and returns
            the encapsulated values in one of the corresponding
            result enumerators, left or right.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <param name="source">Source enumerator of either monads.</param>
            <returns>
            A tuple containing an enumerator of all left-values an an enumerator
            with all right values.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="source"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Either.MapEither``3(Interlook.Monads.Either{``0,``1},System.Func{``0,``2},System.Func{``1,``2})">
            <summary>
            Evaluates the either with one of two given mapping functions.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <typeparam name="TResult">Right .</typeparam>
            <param name="either">Either monad.</param>
            <param name="leftFunction">Function to be used for left state.</param>
            <param name="rightFunction">Function to be used for right state.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/>, <paramref name="leftFunction"/> or <paramref name="rightFunction"/> was <c>null</c>.
            </exception>
        </member>
        <member name="T:Interlook.Monads.EitherLazy`2">
            <summary>
            Either-monad with deferred execution.
            </summary>
            <typeparam name="TLeft">Data type of 'Left'</typeparam>
            <typeparam name="TRight">Data type of 'Right'</typeparam>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.EitherLazy`1">
            <summary>
            Class with static helper/factory methods
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
        </member>
        <member name="M:Interlook.Monads.EitherLazy`1.Right``1(System.Func{``0})">
            <summary>
            Factory method for a lazy either instance with a right value
            </summary>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="valueFactory">Factory method for the right value.</param>
        </member>
        <member name="M:Interlook.Monads.EitherLazy`1.Return``1(System.Func{``0})">
            <summary>
            Creates a lazy either instance with a right value.
            </summary>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="valueFactory">Factory method for the right value.</param>
        </member>
        <member name="M:Interlook.Monads.EitherLazy`1.Left``1(System.Func{`0})">
            <summary>
            Factory method for a lazy either instance with a left value
            </summary>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="valueFactory">Factory method for the left value.</param>
        </member>
        <member name="T:Interlook.Monads.EitherLazy">
            <summary>
            Class with static extension and factory methods
            </summary>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Left``2(System.Func{``0})">
            <summary>
            Factory method for a lazy either instance with a left value
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="valueFactory">Factory method for the left value.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="valueFactory"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Left``2(``0)">
            <summary>
            Factory method for a lazy either instance with a left value
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="value">The left value</param>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Right``2(System.Func{``1})">
            <summary>
            Factory method for a lazy either instance with a right value
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="valueFactory">Factory method for the right value.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="valueFactory"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Right``2(``1)">
            <summary>
            Factory method for a lazy either instance with a right value
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="value">The right value</param>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Create``2(System.Func{System.Boolean},System.Func{``1},System.Func{``0})">
            <summary>
            Factory method for a lazy either instance, whose state is
            determined by a predicate function
            </summary>
            <typeparam name="TLeft">The left type.</typeparam>
            <typeparam name="TRight">The right type.</typeparam>
            <param name="predicate">The predicate function, which determines,
            whether the instance will be in left or right state and thus
            which factory method will be used.</param>
            <param name="rightValueFactory">Factory method for the right value.</param>
            <param name="leftValueFactory">Factory method for the left value.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="predicate"/>, <paramref name="rightValueFactory"/> 
            or <paramref name="leftValueFactory"/> was <c>null</c>
            </exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.IsLeft``2(Interlook.Monads.EitherLazy{``0,``1})">
            <summary>
            Evaluates the either monad and returns if it
            is in the left-state
            </summary>
            <typeparam name="L">The left data type</typeparam>
            <typeparam name="R">The right data type</typeparam>
            <param name="either">A lazy either instance.</param>
            <returns>
              <c>true</c> if the specified either is left; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">either was <c>null</c></exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.IsRight``2(Interlook.Monads.EitherLazy{``0,``1})">
            <summary>
            Evaluates the either monad and returns if it
            is in the right-state
            </summary>
            <typeparam name="L">The left data type</typeparam>
            <typeparam name="R">The right data type</typeparam>
            <param name="either">A lazy either instance.</param>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.GetLeft``2(Interlook.Monads.EitherLazy{``0,``1})">
            <summary>
            Evaluates the either monad and returns the left value.
            Will throw an exception, if the encapsulated either\
            is not in left-state.
            </summary>
            <typeparam name="TLeft"></typeparam>
            <typeparam name="TRight"></typeparam>
            <param name="either"></param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.GetRight``2(Interlook.Monads.EitherLazy{``0,``1})">
            <summary>
            Evaluates the either monad and returns the right value.
            Will throw an exception, if the encapsulated either\
            is not in right-state.
            </summary>
            <typeparam name="TLeft">The type of the left.</typeparam>
            <typeparam name="TRight">The type of the right.</typeparam>
            <param name="either">The either.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="either"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Bind``3(Interlook.Monads.EitherLazy{``0,``1},System.Func{``1,Interlook.Monads.Either{``0,``2}})">
            <summary>
            Binds the specified function.
            </summary>
            <typeparam name="TLeft">The left data type</typeparam>
            <typeparam name="TRightSource">The right type of the specified either.</typeparam>
            <typeparam name="TRightResult">The right type of the resulting either instance.</typeparam>
            <param name="either">First either instance.</param>
            <param name="functionToBind">The function to bind.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/> or <paramref name="functionToBind"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Bind``3(Interlook.Monads.EitherLazy{``0,``1},System.Func{``1,Interlook.Monads.EitherLazy{``0,``2}})">
            <summary>
            Binds the specified function.
            </summary>
            <typeparam name="TLeft">The left data type</typeparam>
            <typeparam name="TRightSource">The right type of the specified either.</typeparam>
            <typeparam name="TRightResult">The right type of the resulting either instance.</typeparam>
            <param name="either">First either instance.</param>
            <param name="functionToBind">The function to bind.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/> or <paramref name="functionToBind"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.FailIf``2(Interlook.Monads.EitherLazy{``0,``1},System.Func{``1,System.Boolean},``0)">
            <summary>
            Switches to the left (failed) state under conditions, defined by a function.
            If this function results in <c>false</c>, nothing is altered.
            </summary>
            <typeparam name="TLeft">Left data type (Error)</typeparam>
            <typeparam name="TRight">Right data type (Result)</typeparam>
            <param name="either">Either-object</param>
            <param name="errorCondition">Error condition.</param>
            <param name="errorValue">Error value, assigned to left state if function fails.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/>, <paramref name="errorCondition"/> or <paramref name="errorValue"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.SelectMany``4(Interlook.Monads.EitherLazy{``0,``1},System.Func{``1,Interlook.Monads.EitherLazy{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Just for LINQ-Query-Support
            </summary>
            <typeparam name="L"></typeparam>
            <typeparam name="R1">The type of the 1.</typeparam>
            <typeparam name="R2">The type of the 2.</typeparam>
            <typeparam name="TR">The type of the r.</typeparam>
            <param name="either">a.</param>
            <param name="selector">The function.</param>
            <param name="mapper">The select.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/>, <paramref name="selector"/> or <paramref name="mapper"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Select``3(Interlook.Monads.EitherLazy{``0,``1},System.Func{``1,``2})">
            <summary>
            Just for LINQ-Query-Support
            </summary>
            <typeparam name="L">The common left data type</typeparam>
            <typeparam name="R1">The type of the 1.</typeparam>
            <typeparam name="R2">The type of the 2.</typeparam>
            <param name="either">The either.</param>
            <param name="selector">The selector.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="either"/> or <paramref name="selector"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Lefts``2(System.Collections.Generic.IEnumerable{Interlook.Monads.EitherLazy{``0,``1}})">
            <summary>
            Returns an enumerator that eventually will
            evaluate an enumerator of lazy either monads
            and only containing those, encapsulating
            either monads in the left-state.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <param name="source">Source enumerator of lazy either monads.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="source"/>was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Rights``2(System.Collections.Generic.IEnumerable{Interlook.Monads.EitherLazy{``0,``1}})">
            <summary>
            Returns an enumerator that eventually will
            evaluate an enumerator of lazy either monads
            and only containing those, encapsulating
            either monads in the right-state.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <param name="source">Source enumerator of lazy either monads.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="source"/>was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.PartitionEithers``2(System.Collections.Generic.IEnumerable{Interlook.Monads.EitherLazy{``0,``1}})">
            <summary>
            Returns two enumerators, which eventually will
            evaluate an enumerator of lazy either monads,
            one only containing those, encapsulating
            either monads in the left-state and the other
            one thos in the right-state.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <param name="source">Source enumerator of lazy either monads.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="source"/>was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.MapEither``3(Interlook.Monads.EitherLazy{``0,``1},System.Func{``0,``2},System.Func{``1,``2})">
            <summary>
            Instantly evaluates the lazy either with one of two given mapping functions.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <typeparam name="TResult">Right .</typeparam>
            <param name="either">Lazy either monad.</param>
            <param name="leftFunction">Function to be used for left state.</param>
            <param name="rightFunction">Function to be used for right state.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="either"/>, 
            <paramref name="leftFunction"/> or <paramref name="rightFunction"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.EitherLazy.Memoize``2(Interlook.Monads.EitherLazy{``0,``1})">
            <summary>
            Returns an <see cref="T:Interlook.Monads.EitherLazy`2" />-instance,
            encapsulating all underlying evaluations, thus ensuring
            they are executed only once.
            </summary>
            <typeparam name="TLeft">Left data type.</typeparam>
            <typeparam name="TRight">Right data type.</typeparam>
            <param name="either">Lazy either monad.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="either"/>was <c>null</c>.</exception>
        </member>
        <member name="T:Interlook.Monads.Maybe`1">
            <summary>
            Strict implementation of maybe, thus without lazy execution.
            Assignments and bindings are executed instantly.
            </summary>
            <typeparam name="T">Type of the encapsulated value.</typeparam>
        </member>
        <member name="M:Interlook.Monads.Maybe`1.BindInternal``1(System.Func{`0,Interlook.Monads.Maybe{``0}})">
            <summary>
            Binds, in overriding classes, a function to the instance.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="func">The function to bind.</param>
        </member>
        <member name="T:Interlook.Monads.Nothing`1">
            <summary>
            Implements an empty <see cref="T:Interlook.Monads.Maybe`1"/>.
            </summary>
            <typeparam name="T">Type of the value of the implemented maybe.</typeparam>
        </member>
        <member name="P:Interlook.Monads.Nothing`1.Instance">
            <summary>
            A default empty maybe.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Nothing`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Nothing`1.GetHashCode">
            <summary>
            Returns constant hash value 0 for <see cref="T:Interlook.Monads.Nothing`1"/>-instances.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Nothing`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Nothing`1.BindInternal``1(System.Func{`0,Interlook.Monads.Maybe{``0}})">
            <summary>
            Does not actually bind the function, since the maybe object is nothing.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="func">The function to bind.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.Just`1">
            <summary>
            Implements a <see cref="T:Interlook.Monads.Maybe`1"/>-object with an existing value.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
        </member>
        <member name="P:Interlook.Monads.Just`1.Value">
            <summary>
            Gets the actual value.
            </summary>
            <remarks>
            The value may be <c>null</c> for reference types, since this is a possible value for objects.
            Do not confuse <c>null</c> and <see cref="T:Interlook.Monads.Nothing`1"/>!
            </remarks>
        </member>
        <member name="M:Interlook.Monads.Just`1.#ctor(`0)">
            <summary>
            Creates a maybe-type with a set value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Interlook.Monads.Just`1.ToString">
            <summary>
            Converts the encapsulated value to a string.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Just`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Interlook.Monads.Just`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Just`1.Equals(Interlook.Monads.Just{`0},Interlook.Monads.Just{`0})">
            <summary>
            Determines, if two valued maybe-object are equal (not necessarily identical),
            based on the encapsulated value, if present.
            </summary>
            <param name="x">The first maybe-object to match.</param>
            <param name="y">The second maybe-object to match.</param>
            <returns><c>true</c>, if both arguments aren't <c>null</c> and wrap the same value.</returns>
        </member>
        <member name="M:Interlook.Monads.Just`1.BindInternal``1(System.Func{`0,Interlook.Monads.Maybe{``0}})">
            <summary>
            Binds a function to the maybe instance.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="func">The function to bind.</param>
            <returns>The result of the <paramref name="func"/></returns>
        </member>
        <member name="T:Interlook.Monads.MaybeExtensions">
            <summary>
            Extension methods for <see cref="T:Interlook.Monads.Maybe`1"/> types.
            </summary>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.ToMaybe``1(``0)">
            <summary>
            Puts a value into a strict maybe monad. (see <see cref="T:Interlook.Monads.Maybe`1"/>)
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="value">The object/value to be wrapped in a maybe-object.</param>
            <returns>A maybe-object wrapping the given object.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.ToMaybe``1(``0,System.Func{``0,System.Boolean})">
            <summary>
            Puts a value into a strict maybe monad. (see <see cref="T:Interlook.Monads.Maybe`1" />)
            and uses a filter function for distiction (<see cref="T:Interlook.Monads.Just`1" /> vs. <see cref="T:Interlook.Monads.Nothing`1" /> ).
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="value">The object/value to be wrapped in a maybe-object.</param>
            <param name="predicate">The  (filter) function to decide, if the
            object is wrapped into <see cref="T:Interlook.Monads.Nothing`1" /> or <see cref="T:Interlook.Monads.Just`1" />.</param>
            <returns>
            <returns>A <see cref="T:Interlook.Monads.Just`1" /> instance, if the predicate function returned <c>true</c>,
            otherwise a <see cref="T:Interlook.Monads.Nothing`1" /> object.</returns>
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="predicate"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.ToMaybeNotNull``1(``0)">
            <summary>
            Puts a value into a strict maybe monad. (see <see cref="T:Interlook.Monads.Maybe`1"/>)
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The object to be wrapped in a maybe-object.</param>
            <returns>A <see cref="T:Interlook.Monads.Just`1"/> instance, if the object was not <c>null</c>, otherwise
            a <see cref="T:Interlook.Monads.Nothing`1"/> object.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.SelectMany``3(Interlook.Monads.Maybe{``0},System.Func{``0,Interlook.Monads.Maybe{``1}},System.Func{``0,``1,``2})">
            <summary>
            Extension method to make the LINQ FROM-notation usable for Maybe[T] for multiple disjunct FROMs
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="B"></typeparam>
            <typeparam name="C"></typeparam>
            <param name="obj">The maybe aggregate.</param>
            <param name="collector">The function to bind.</param>
            <param name="select">The result flattening selector.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/>, <paramref name="collector"/> or <paramref name="select"/> was <c>null</c>;
            </exception>
            <remarks>
            Multiple disjunct FROMs means:
            the notation
            <code>
            from a in s1
            from b in s2
            select a + b
            </code>
            is tanslated to:
            <code>
            s1.SelectMany(x =&gt; s2, (a, b) =&gt; a + b)
            </code>
            </remarks>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.Where``1(Interlook.Monads.Maybe{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the aggregate if the query function succeeds.
            </summary>
            <typeparam name="T">Datatype of the maybe aggregate</typeparam>
            <param name="obj">The maybe aggregate.</param>
            <param name="query">The query (predicate) for keeping the maybe,
            rather than returning Nothing[T].</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> or <paramref name="query"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.Select``2(Interlook.Monads.Maybe{``0},System.Func{``0,``1})">
            <summary>
            Selector function for LINQ support.
            Similiar to the <see cref="M:Interlook.Monads.MaybeExtensions.Bind``2(Interlook.Monads.Maybe{``0},System.Func{``0,Interlook.Monads.Maybe{``1}})"/> method,
            with the difference, that the selector function here does not return a <see cref="T:Interlook.Monads.Maybe`1"/>-type,
            but a arbitrary datatype, that is encapsulated afterwards.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">Das Maybe-Objekt.</param>
            <param name="selector">Selector function, similiar to a bind-function.</param>
            <returns>Result of the selector function, that has been encapsulated into a <see cref="T:Interlook.Monads.Just`1"/>-
            or a <see cref="T:Interlook.Monads.Nothing`1"/>-object. The latter one applies, if the provided maybe monad
            was already Nothing.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> or <paramref name="selector"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.Bind``2(Interlook.Monads.Maybe{``0},System.Func{``0,Interlook.Monads.Maybe{``1}})">
            <summary>
            Binds an aggregate function (strict = non lazy)
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">The maybe monad.</param>
            <param name="functionToBind">The function to bind.</param>
            <returns>The resulting aggregate (maybe object) after binding the function to the given aggregate.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> or <paramref name="functionToBind"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.Apply``1(Interlook.Monads.Maybe{``0},System.Action{``0})">
            <summary>
            Applies an action on the specified aggregate.
            </summary>
            <typeparam name="T">Encapsulated data type</typeparam>
            <param name="obj">The maybe monad.</param>
            <param name="actionToApply">The action to apply.</param>
            <returns>The aggregate that was provided.</returns>
            <remarks>
            This method may cause side effects using the aggregate value and
            does not change the aggregate itself.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> or <paramref name="actionToApply"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.Apply``1(Interlook.Monads.Maybe{``0},System.Action{``0},System.Func{``0,System.Boolean})">
            <summary>
            Applies an action on the specified aggregate, depending on a predicate function.
            </summary>
            <typeparam name="T">Encapsulated data type</typeparam>
            <param name="obj">The maybe monad.</param>
            <param name="actionToApply">The action to apply.</param>
            <param name="predicate">The predicate function to decide, whether to
            applay the action on the aggregate.</param>
            <returns>
            The aggregate that was provided.
            </returns>
            <remarks>
            This method may cause side effects using the aggregate value and
            does not change the aggregate itself.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/>,
            <paramref name="predicate"/> or <paramref name="actionToApply"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.HasValue``1(Interlook.Monads.Maybe{``0})">
            <summary>
            Determines whether the specified maybe-object has a value.
            </summary>
            <typeparam name="T">The type of the object-type</typeparam>
            <param name="obj">The maybe-object to check.</param>
            <returns><c>true</c>, if the maybe-object contains a value. <seealso cref="T:Interlook.Monads.Just`1"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.IsNothing``1(Interlook.Monads.Maybe{``0})">
            <summary>
            Determines whether the specified maybe-object has no value.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object to check.</param>
            <returns><c>true</c>, if the maybe-object contains no value. <seealso cref="T:Interlook.Monads.Nothing`1"/></returns>
            <remarks>
            Do not confuse <c>null</c> and <see cref="T:Interlook.Monads.Nothing`1"/>!
            This method also returns <c>true</c>, if a maybe's value is <c>null</c>,
            since this is a valid value for objects.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.GetValue``1(Interlook.Monads.Maybe{``0},``0)">
            <summary>
            Gets the value of the maybe-object.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="defaultValue">The default value to return, if the maybe object contains no value.</param>
            <returns>The value of the maybe-object, if existing, or the given default value otherwise.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.Otherwise``1(Interlook.Monads.Maybe{``0},Interlook.Monads.Maybe{``0})">
            <summary>
            Returns another maybe-object, if the maybe-object is empty (<see cref="T:Interlook.Monads.Nothing`1"/>)
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="defaultMaybe">The default maybe-object, if the given maybe-object is empty.</param>
            <returns>The original maybe-object, if it contains a value; otherwise the given default maybe-object.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> or <paramref name="defaultMaybe"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.OtherwiseThrow``1(Interlook.Monads.Maybe{``0},System.Exception)">
            <summary>
            Throws an exception, if the maybe-aggregate is empty (<see cref="T:Interlook.Monads.Nothing`1"/>)
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="exceptionToThrow">The exception to throw.</param>
            <returns>The original maybe-aggregate, if it contains a value</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> or <paramref name="exceptionToThrow"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.Satisfies``1(Interlook.Monads.Maybe{``0},System.Func{``0,System.Boolean})">
            <summary>
            Executes a predicate query with the maybe-object's value.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="predicate">The predicate to execute with the maybe-object's value.</param>
            <returns>
            A maybe-object, containing the boolean result of the given predicate, if the maybe-object contains a value;
            otherwise an empty maybe-value.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> or <paramref name="predicate"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.MapMaybe``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Interlook.Monads.Maybe{``1}})">
            <summary>
            Version of Map (LINQ Select), applying a mapping function, which returns a maybe monad,
            to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> and only returns values of <see cref="T:Interlook.Monads.Just`1"/>-instances,
            thus leaving out <see cref="T:Interlook.Monads.Nothing`1"/>-elements.
            </summary>
            <typeparam name="TSource">The type of the objects within the source enumerator.</typeparam>
            <typeparam name="TResult">The type of the objects within the result enumerator.</typeparam>
            <param name="source">The source enumerator.</param>
            <param name="selector">The result selector function.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="selector"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.MaybeToList``1(Interlook.Monads.Maybe{``0})">
            <summary>
            Returns the value, encapsulated by a maybe-monad,
            as an enumerator, returning nothing for a <see cref="T:Interlook.Monads.Nothing`1"/>-instance
            and the encapsulated value otherwise.</summary>
            <typeparam name="T">The encapsulated data type.</typeparam>
            <param name="obj">The maybe instance.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="obj"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.CatMaybes``1(System.Collections.Generic.IEnumerable{Interlook.Monads.Maybe{``0}})">
            <summary>
            Returns for an enumerator of maybe-instances the
            actual encapsulated values inside an enumerator,
            leaving out <see cref="T:Interlook.Monads.Nothing`1"/>-instances.
            </summary>
            <typeparam name="T">Data type, encapsulated by the maybe-monad in the source enumerator.</typeparam>
            <param name="source">The source enumerator.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.FirstToMaybe``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Puts the first element returned by the enumerator into a maybe-monad,
            returning <see cref="T:Interlook.Monads.Nothing`1"/> for an empty enumerator.
            </summary>
            <typeparam name="T">Data type, encapsulated by the maybe-monad in the source enumerator.</typeparam>
            <param name="source">The source enumerator.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.MaybeExtensions.FirstToMaybe``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Puts the first element returned by the enumerator, that matches a given filter,
            into a maybe-monad, returning <see cref="T:Interlook.Monads.Nothing`1"/> for an enumerator with
            no matching elements.
            </summary>
            <typeparam name="T">Data type, encapsulated by the maybe-monad in the source enumerator.</typeparam>
            <param name="source">The source enumerator.</param>
            <param name="predicate">The filter criterion.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> or <paramref name="predicate"/> was <c>null</c>.</exception>
        </member>
        <member name="T:Interlook.Monads.MaybeLazy`1">
            <summary>
            Lazy implementation of maybe, thus with deferred execution.
            Assignments and bindings are executed not before
            the monad is evaluated (e.g. by <c>GetValue, HasValue, IsNothing</c> etc.)
            </summary>
            <typeparam name="T">Type of the encapsulated value.</typeparam>
        </member>
        <member name="T:Interlook.Monads.MaybeLazy">
             <summary>
             Maybe-Monad with deferred execution.
             Increases reusability of maybe instances.
             </summary>
             <remarks>
             When using the lazy version of maybe (corresponding to the native Maybe in Haskell) one has to consider,
             that some methods like <see cref="M:Interlook.Monads.MaybeLazyExtensions.GetValue``1(Interlook.Monads.MaybeLazy{``0},``0)"/>
             or <see cref="M:Interlook.Monads.MaybeLazyExtensions.IsNothing``1(Interlook.Monads.MaybeLazy{``0})"/> evaluate the monad, so multiple executions
             of the same actions are possible in inept code.
             </remarks>
             <example>
             Following code is ineffective:
            
             <code>
             <![CDATA[MaybeLazy<int>]]> m = getSomeLazyMaybe();
             // DONT DO THAT
             if(m.HasValue())        // Maybe is evaluated
             {
                 doSomething(m.GetValue(0));     // Maybe is evaluated again
             }
             </code>
            
             Better:
            
             <code>
             <![CDATA[MaybeLazy<int>]]> m = getSomeLazyMaybe();
             var mb = m();           // returning a strict maybe, that is already evaluated
             if(mb.HasValue())
             {
                 doSomething(mb.GetValue(0));        // no re-evaluation
             }
             </code>
            
             This code is only for illustration. If your code uses HasValue() with following GetValue often,
             you should review the correct usage of lazy maybes.
             </example>
        </member>
        <member name="M:Interlook.Monads.MaybeLazy.Nothing``1">
            <summary>
            Returns a <see cref="T:Interlook.Monads.MaybeLazy`1"/> instance, that will
            later result in <see cref="M:Interlook.Monads.MaybeLazy.Nothing``1"/>.
            </summary>
            <typeparam name="T">Encapsulated data type.</typeparam>
            <returns>An instance of <see cref="T:Interlook.Monads.MaybeLazy`1"/>,
            that encapsulates no value (see <see cref="M:Interlook.Monads.MaybeLazy.Nothing``1"/></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazy.NothingLike``1(``0)">
            <summary>
            Returns a <see cref="T:Interlook.Monads.MaybeLazy`1"/> instance, that will
            later result in <see cref="M:Interlook.Monads.MaybeLazy.Nothing``1"/>.
            This overload is syntactical only sugar.
            </summary>
            <typeparam name="T">Encapsulated data type.</typeparam>
            <param name="dummy">Unused dummy value, that is only used for type inference.</param>
            <returns>An instance of <see cref="T:Interlook.Monads.MaybeLazy`1"/>,
            that encapsulates no value (see <see cref="M:Interlook.Monads.MaybeLazy.Nothing``1"/></returns>
            <example>
            <code>
                var m = MaybeLazy.NothingLike(1);   // gets us an <![CDATA[Nothing<int>]]>
                var n = MaybeLazy.<![CDATA[Nothing<int>]]>();   // same result as above
            </code>
            </example>
        </member>
        <member name="M:Interlook.Monads.MaybeLazy.Just``1(``0)">
            <summary>
            Returns an instance of <see cref="T:Interlook.Monads.MaybeLazy`1"/>, that will
            result in <see cref="M:Interlook.Monads.MaybeLazy.Just``1(``0)"/> later.
            </summary>
            <typeparam name="T">Encapsulated data type.</typeparam>
            <returns>An instance of <see cref="T:Interlook.Monads.MaybeLazy`1"/>,
            encapsulating the given value (see <see cref="M:Interlook.Monads.MaybeLazy.Just``1(``0)"/></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazy.Return``1(System.Func{``0})">
            <summary>
            Returns an instance of <see cref="T:Interlook.Monads.MaybeLazy`1"/>, that will
            result in <see cref="M:Interlook.Monads.MaybeLazy.Just``1(``0)"/> later, encapsulating
            the return value of a function .
            </summary>
            <typeparam name="T">Encapsulated data type.</typeparam>
            <param name="selector">Function, which returns the value to be encapsulated.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazy.ReturnIf``1(System.Func{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns an instance of <see cref="T:Interlook.Monads.MaybeLazy`1"/>, that will
            result in <see cref="M:Interlook.Monads.MaybeLazy.Just``1(``0)" /> or <see cref="M:Interlook.Monads.MaybeLazy.Nothing``1" />,
            depending on whether the return value of the given function matches
            the filter criterion, defined by the provided predicate function.
            </summary>
            <typeparam name="T">Encapsulated data type.</typeparam>
            <param name="selector">Function, which returns the value to be encapsulated.</param>
            <param name="predicate">Filter predicate function.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.MaybeLazyExtensions">
            <summary>
            Extension methods for <see cref="T:Interlook.Monads.MaybeLazy`1"/> types.
            </summary>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.ToMaybeLazy``1(``0)">
            <summary>
            Puts an object into a lazy maybe monad (see <see cref="T:Interlook.Monads.MaybeLazy`1"/>)
            resulting in a <see cref="T:Interlook.Monads.Just`1"/> object.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="value">The object/value to be wrapped in a maybe-object.</param>
            <returns>A maybe-object wrapping the given object.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.ToMaybeLazy``1(``0,System.Func{``0,System.Boolean})">
            <summary>
            Puts an object into a lazy maybe monad (see <see cref="T:Interlook.Monads.MaybeLazy`1"/>)
            by using a filter function for distinguising between
            <see cref="T:Interlook.Monads.Just`1"/> and <see cref="T:Interlook.Monads.Nothing`1"/>.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="value">The object/value to be wrapped in a maybe-object.</param>
            <param name="predicate">The  (filter) function to decide, if the
            object is wrapped into <see cref="T:Interlook.Monads.Nothing`1"/> or <see cref="T:Interlook.Monads.Just`1"/>.</param>
            <returns>
              <returns>A <see cref="T:Interlook.Monads.Just`1"/> instance, if the predicate function returned <c>true</c>,
            otherwise a <see cref="T:Interlook.Monads.Nothing`1"/> object.</returns>
            </returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.ToMaybeLazyNotNull``1(``0)">
            <summary>
            Puts an object into a lazy maybe monad (see <see cref="T:Interlook.Monads.MaybeLazy`1"/>)
            resulting in a <see cref="T:Interlook.Monads.Just`1"/> or <see cref="T:Interlook.Monads.Just`1"/> object,
            depending on the object being <c>null</c>.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="value">The object to be wrapped in a maybe-object.</param>
            <returns>A <see cref="T:Interlook.Monads.Just`1"/> instance, if the object was not <c>null</c>, otherwise
            a <see cref="T:Interlook.Monads.Nothing`1"/> object.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.SelectMany``3(Interlook.Monads.MaybeLazy{``0},System.Func{``0,Interlook.Monads.MaybeLazy{``1}},System.Func{``0,``1,``2})">
             <summary>
             Extension method to make the LINQ FROM-notation usable for Maybe[T] for multiple disjunct FROMs
             </summary>
             <typeparam name="T1">Gekapselter Datentyp des 1. Maybe-Aggregats</typeparam>
             <typeparam name="T2">Gekapselter Datentyp des 2. Maybe-Aggregats</typeparam>
             <typeparam name="TResult">Gekapselter Datentyp des Ergebnis-Maybe-Aggregats</typeparam>
             <param name="obj">The maybe aggregate.</param>
             <param name="func">The function to bind.</param>
             <param name="select">The result flattening selector.</param>
             <returns></returns>
             <remarks>
             Multiple disjunct FROMs means:
            		the notation
            		<code>
            			from a in s1
            			from b in s2
            			select a + b
            		</code>
            
            		is tanslated to:
            		<code>
            			s1.SelectMany(a => s2, (s1, b) => a + b)
            		</code>
             </remarks>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Where``1(Interlook.Monads.MaybeLazy{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the aggregate if the query function succeeds.
            </summary>
            <typeparam name="T">Datatype of the maybe aggregate</typeparam>
            <param name="obj">The maybe aggregate.</param>
            <param name="query">The query (predicate) for keeping the maybe,
            rather than returning Nothing[T].</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Select``2(Interlook.Monads.MaybeLazy{``0},System.Func{``0,``1})">
            <summary>
            Selector function for LINQ support.
            Similiar to <see cref="M:Interlook.Monads.MaybeLazyExtensions.Bind``2(Interlook.Monads.MaybeLazy{``0},System.Func{``0,Interlook.Monads.Maybe{``1}})" /> method,
            but here, the selector function does not return an <see cref="T:Interlook.Monads.MaybeLazy`1" />-type,
            but an arbitrary data type.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">The maybe instance.</param>
            <param name="selector">The selector function, returning a value to be encapsluated.</param>
            <returns>
            The result of the selector function encapsulated in an <see cref="T:Interlook.Monads.Just`1" />-instance
            or <see cref="T:Interlook.Monads.Nothing`1" />, if the given maybe monad was <c>Nothing</c> already.
            </returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Bind``2(Interlook.Monads.MaybeLazy{``0},System.Func{``0,Interlook.Monads.Maybe{``1}})">
            <summary>
            Binds an aggregate function to a lazy maybe monad.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">The maybe aggregate.</param>
            <param name="functionToBind">The function to bind.</param>
            <returns>The resulting aggregate (maybe object) after binding the function to the given aggregate.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Bind``2(Interlook.Monads.MaybeLazy{``0},System.Func{``0,Interlook.Monads.MaybeLazy{``1}})">
            <summary>
            Binds an aggregate function to a lazy maybe monad.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">The maybe aggregate.</param>
            <param name="functionToBind">The function to bind.</param>
            <returns>The resulting aggregate (maybe object) after binding the function to the given aggregate.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Apply``1(Interlook.Monads.MaybeLazy{``0},System.Action{``0})">
            <summary>
            Evaluates the lazy monad and executes an action instantly.
            </summary>
            <typeparam name="T">Type of the aggregate (maybe object)</typeparam>
            <param name="obj">The lazy maybe monad.</param>
            <param name="actionToApply">The action to apply.</param>
            <returns>A strict <see cref="T:Interlook.Monads.Maybe`1"/>-object, encapsulating the same value
            as the provided lazy one.</returns>
            <remarks>
            This method may cause side effects with the aggregate value and
            does not change the aggregate itself.
            </remarks>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Memoize``1(Interlook.Monads.MaybeLazy{``0})">
            <summary>
            Creates an <see cref="T:Interlook.Monads.MaybeLazy`1"/>-instance, encapsulating
            all underlying evaluations, thus ensuring, they are
            executed only one time.
            </summary>
            <typeparam name="T">The encapsulated data typ</typeparam>
            <param name="obj">The lazy maybe monad</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Apply``1(Interlook.Monads.MaybeLazy{``0},System.Action{``0},System.Func{``0,System.Boolean})">
            <summary>
            Evaluates the lazy Maybe monad instantly and performs an action accordingly,
            if the evaluated value matches a specified filter criterion.
            Then the delayed Maybe will not be returned to re-run
            to avoid the chain of recombination.
            </summary>
            <typeparam name="T">Type of the aggregate (maybe object)</typeparam>
            <param name="obj">The aggregate.</param>
            <param name="actionToApply">The action to apply.</param>
            <param name="predicate">The predicate function to decide, whether to
            applay the action on the aggregate.</param>
            <returns>
            The aggregate that was provided.
            </returns>
            <remarks>
            This method just causes side effects on the aggregate value and
            does not change the aggregate itself.
            </remarks>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.HasValue``1(Interlook.Monads.MaybeLazy{``0})">
            <summary>
            Evaluates the lazy maybe monad and returns, if it actually contains a value.
            </summary>
            <typeparam name="T">The type of the object-type</typeparam>
            <param name="obj">The maybe-object to check.</param>
            <returns><c>true</c>, if the maybe-object contains a value. <seealso cref="T:Interlook.Monads.Just`1"/></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.IsNothing``1(Interlook.Monads.MaybeLazy{``0})">
            <summary>
            Evaluates the lazy maybe monad and returns, if it does not contain a value.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object to check.</param>
            <returns><c>true</c>, if the maybe-object contains no value. <seealso cref="T:Interlook.Monads.Nothing`1"/></returns>
            <remarks>
            Do not confuse <c>null</c> and <see cref="T:Interlook.Monads.Nothing`1"/>!
            This method also returns <c>true</c>, if a maybe's value is <c>null</c>,
            since this is a valid value for objects.
            </remarks>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.GetValue``1(Interlook.Monads.MaybeLazy{``0},``0)">
            <summary>
            Evaluates the lazy maybe monad and returns its value or
            and defaqult value, depending on it encapsulating a
            <see cref="T:Interlook.Monads.Just`1"/>- or <see cref="T:Interlook.Monads.Nothing`1"/>-object.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="defaultValue">The default value to return, if the maybe object contains no value.</param>
            <returns>The value of the maybe-object, if existing, or the given default value otherwise.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Otherwise``1(Interlook.Monads.MaybeLazy{``0},Interlook.Monads.MaybeLazy{``0})">
            <summary>
            Returns an new lazy maybe monad, resulting in an alternative maybe monad,
            if the current would evaluate to <see cref="T:Interlook.Monads.Nothing`1"/>.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="defaultMaybe">The default maybe-object, if the given maybe-object is empty.</param>
            <returns>The original maybe-object, if it contains a value; otherwise the given default maybe-object.</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.OtherwiseThrow``1(Interlook.Monads.MaybeLazy{``0},System.Exception)">
            <summary>
            Returns a lazy maybe monad, that will throw an exception,
            if it results in <see cref="T:Interlook.Monads.Nothing`1"/> when evaluated.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="exceptionToThrow">The exception to throw.</param>
            <returns>The original maybe-aggregate, if it contains a value</returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.Satisfies``1(Interlook.Monads.MaybeLazy{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns a new lazy maybe monad, encapsulating a <see cref="T:System.Boolean"/>-value,
            that reflects, if the monad results in <see cref="T:Interlook.Monads.Just`1"/>, when evaluated.
            </summary>
            <typeparam name="T">The type of the maybe-object.</typeparam>
            <param name="obj">The maybe-object.</param>
            <param name="predicate">The predicate to execute with the maybe-object's value.</param>
            <returns>
            A maybe-object, containing the boolean result of the given predicate, if the maybe-object contains a value;
            otherwise an empty maybe-value.
            </returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.MapMaybeLazy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Interlook.Monads.MaybeLazy{``1}})">
            <summary>
            Version of Map (LINQ Select), applying a mapping function, which returns a maybe monad,
            to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> and only returns values of <see cref="T:Interlook.Monads.Just`1"/>-instances,
            thus leaving out <see cref="T:Interlook.Monads.Nothing`1"/>-elements.
            </summary>
            <typeparam name="TSource">The type of the objects within the source enumerator.</typeparam>
            <typeparam name="TResult">The type of the objects within the result enumerator.</typeparam>
            <param name="source">The source enumerator.</param>
            <param name="selector">The result selector function.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.MaybeToList``1(Interlook.Monads.MaybeLazy{``0})">
            <summary>
            Evaluates the monad and returns the encapsulated value,
            as an enumerator, returning nothing for a <see cref="T:Interlook.Monads.Nothing`1"/>-instance
            and the encapsulated value otherwise.</summary>
            <typeparam name="T">The encapsulated data type.</typeparam>
            <param name="obj">The maybe instance.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.CatMaybes``1(System.Collections.Generic.IEnumerable{Interlook.Monads.MaybeLazy{``0}})">
            <summary>
            Returns for an enumerator of lazy maybe instances the
            actual encapsulated values inside an enumerator,
            leaving out <see cref="T:Interlook.Monads.Nothing`1"/>-instances.
            </summary>
            <remarks>
            All lazy maybes in the enumerator will be evaluated.
            </remarks>
            <typeparam name="T">Data type, encapsulated by the maybe-monad in the source enumerator.</typeparam>
            <param name="source">The source enumerator.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.FirstToMaybeLazy``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a new lazy maybe monad encapsulating the first element returned by the enumerator
            or <see cref="T:Interlook.Monads.Nothing`1"/> for an empty enumerator.
            </summary>
            <typeparam name="T">Der Elemententyp</typeparam>
            <param name="source">Die Quellauflistung.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.MaybeLazyExtensions.FirstToMaybeLazy``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns a new lazy maybe monad encapsulating the first element of the enumerator
            that matches a given filter or <see cref="T:Interlook.Monads.Nothing`1" /> for an enumerator with
            no matching elements.
            </summary>
            <typeparam name="T">Der Elemententyp</typeparam>
            <param name="source">Die Quellauflistung.</param>
            <param name="predicate">The filter predicate.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="source"/> or <paramref name="predicate"/> was <c>null</c>.
            </exception>
        </member>
        <member name="T:Interlook.Monads.Reader`2">
            <summary>
            Represents a monadic reader.
            This monad is innately lazy.
            </summary>
            <typeparam name="TArgument">The type of the argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Interlook.Monads.Reader`2.#ctor(System.Func{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Monads.Reader`2"/> class.
            </summary>
            <param name="function">The function to be encapsluated.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="function"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.Reader`2.Map``1(System.Func{`1,``0})">
            <summary>
            Maps a reader to a new reader.
            </summary>
            <typeparam name="TResultNew">The type of the result new.</typeparam>
            <param name="function">The function, that selects a type <typeparamref name="TResultNew"/>
            from type <typeparamref name="TResult"/></param>
            <returns>A new <see cref="T:Interlook.Monads.Reader`2"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="function" /> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.Reader`2.Bind``1(System.Func{`1,Interlook.Monads.Reader{`0,``0}})">
            <summary>
            Binds a function to a reader.
            </summary>
            <typeparam name="TResultNew">The type of the result new.</typeparam>
            <param name="function">The function, that selects a type <typeparamref name="TResultNew"/>
            from type <typeparamref name="TResult"/></param>
            <returns>A new <see cref="T:Interlook.Monads.Reader`2"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="function" /> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.Reader`2.GetResult(`0)">
            <summary>
            Gets the result.
            </summary>
            <param name="arg">The argument.</param>
        </member>
        <member name="M:Interlook.Monads.Reader`2.GetResultLazy(`0)">
            <summary>
            Lazily evaluates the reader.
            </summary>
            <param name="arg">The argument.</param>
        </member>
        <member name="T:Interlook.Monads.Reader">
            <summary>
            Contains static extension classes for <see cref="T:Interlook.Monads.Reader`2"/>
            </summary>
        </member>
        <member name="M:Interlook.Monads.Reader.Ask``1">
            <summary>
            Creates a new reader instance for the specified argument type,
            which accepts and returns a value of this very type.
            </summary>
            <typeparam name="TArgument">The argument type.</typeparam>
            <returns>A new reader instance which returns solely the object it was given.</returns>
        </member>
        <member name="M:Interlook.Monads.Reader.Ask``1(System.Func{``0,``0})">
            <summary>
            Creates a new reader instance for the specified argument type,
            which accepts and returns a value of this very type.
            </summary>
            <typeparam name="TArgument">The argument type.</typeparam>
            <returns>A new reader instance which returns the provided object
            after it was processed by <paramref name="func"/>.</returns>
        </member>
        <member name="M:Interlook.Monads.Reader.ReturnReader``2(``1)">
            <summary>
            Returns a new reader instance that always returns a specified value,
            independent of the provided argument.
            </summary>
            <typeparam name="TArgument">The type of the argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="value">The value to return. Defaults to <c>default&lt;TResult&gt;</c>, if not specified.</param>
            <returns>A new reader with constant return value.</returns>
        </member>
        <member name="M:Interlook.Monads.Reader.ReturnReader``2">
            <summary>
            Returns a new reader instance that always returns the default of a specified type,
            independent of the provided argument.
            </summary>
            <typeparam name="TArgument">The type of the argument.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <returns>A new reader with constant return value.</returns>
        </member>
        <member name="M:Interlook.Monads.Reader.SelectMany``4(Interlook.Monads.Reader{``0,``1},System.Func{``1,Interlook.Monads.Reader{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            For LINQ-Query-Support
            </summary>
            <typeparam name="TArgument">The type of the argument.</typeparam>
            <typeparam name="TResult">The type of the result of the specified reader</typeparam>
            <typeparam name="TCollector">The result-type of the reader returned by <paramref name="collector"/>.</typeparam>
            <typeparam name="TResultNew">The result-type, returned by <paramref name="selector"/>.</typeparam>
            <param name="obj">A reader object.</param>
            <param name="collector">A function, selecting another reader object from the result of <paramref name="obj"/>.</param>
            <param name="selector">A function, selecting the final result from the results of
                <paramref name="obj"/> and the reader returned by <paramref name="collector"/>.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/>, <paramref name="collector"/> or <paramref name="selector"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Reader.Select``3(Interlook.Monads.Reader{``0,``1},System.Func{``1,``2})">
            <summary>
            For LINQ support. Just calls <see cref="M:Interlook.Monads.Reader`2.Map``1(System.Func{`1,``0})"/>
            </summary>
            <typeparam name="TArgument">The type of the argument.</typeparam>
            <typeparam name="TResult">The type of the result of the specified reader</typeparam>
            <typeparam name="TResultNew">The type of the result new.</typeparam>
            <param name="obj">A reader object.</param>
            <param name="function">The function, that selects a type <typeparamref name="TResultNew"/>
            from type <typeparamref name="TResult"/></param>
            <returns>A new <see cref="T:Interlook.Monads.Reader`2"/> instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/> or <paramref name="function"/> was <c>null</c>.
            </exception>
        </member>
        <member name="T:Interlook.Monads.State`2">
            <summary>
            An implementation of the state monad.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="T:Interlook.Monads.StateEntry`2">
            <summary>
            The result value of the state monad.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="P:Interlook.Monads.StateEntry`2.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="P:Interlook.Monads.StateEntry`2.State">
            <summary>
            Gets the state.
            </summary>
        </member>
        <member name="T:Interlook.Monads.State">
            <summary>
            Extension and factory methods for <see cref="T:Interlook.Monads.StateEntry`2"/>
            </summary>
        </member>
        <member name="M:Interlook.Monads.State.ReturnState``2(``1)">
            <summary>
            Returns a new monadic state object with a certain or default value.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="value">The value for the object. Defaults to <c>default(TValue)</c> if not specified.</param>
            <returns>A new <see cref="T:Interlook.Monads.State`2"/> instance with the specified or the default value.</returns>
        </member>
        <member name="M:Interlook.Monads.State.Get``1(System.Func{``0,``0})">
            <summary>
            Returns a new monadic state object, for which
            the value and state have the same data type and which
            applies a function to the state, to derive the value.
            </summary>
            <typeparam name="TState">The type of the state AND the value.</typeparam>
            <param name="func">The function to derive the value from the state.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="func"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.State.Get``1">
            <summary>
            Returns a new monadic state object, for which
            the value and state have the same data type and content.
            </summary>
            <typeparam name="TState"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.State.Put``1(``0)">
            <summary>
            Returns a new monadic state object with a specified state
            but without any actual value.
            </summary>
            <typeparam name="TState"></typeparam>
            <param name="state">The state.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.State.With``2(Interlook.Monads.State{``0,``1},System.Func{``0,``0})">
            <summary>
            Binds a function to the state of the monadic state object.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="obj">The monadic state object.</param>
            <param name="stateMapper">The state mapper.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/> or <paramref name="stateMapper"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.State.Map``3(Interlook.Monads.State{``0,``1},System.Func{``1,``2})">
            <summary>
            Binds a function to the state of the monadic state object.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value of the original state object.</typeparam>
            <typeparam name="TValueNew">The type of the value of the resulting state object.</typeparam>
            <param name="obj">The monadic state object.</param>
            <param name="valueMapper">The value mapping function.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/> or <paramref name="valueMapper"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.State.Bind``3(Interlook.Monads.State{``0,``1},System.Func{``1,Interlook.Monads.State{``0,``2}})">
            <summary>
            Binds a function to the value of the monadic state object.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value of the original state object.</typeparam>
            <typeparam name="TValueNew">The type of the value of the resulting state object.</typeparam>
            <param name="obj">The monadic state object.</param>
            <param name="func">The value mapping function.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/> or <paramref name="func"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.State.Select``3(Interlook.Monads.State{``0,``1},System.Func{``1,``2})">
            <summary>
            For LINQ support. Just calls <see cref="M:Interlook.Monads.State.Map``3(Interlook.Monads.State{``0,``1},System.Func{``1,``2})"/>
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value of the original state object.</typeparam>
            <typeparam name="TValueNew">The type of the value of the resulting state object.</typeparam>
            <param name="obj">The monadic state object.</param>
            <param name="valueMapper">The value mapping function.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/> or <paramref name="valueMapper"/> was <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.State.SelectMany``4(Interlook.Monads.State{``0,``1},System.Func{``1,Interlook.Monads.State{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            Selects the many.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value of the original state object.</typeparam>
            <typeparam name="TSelect">The type of the value of the second state object.</typeparam>
            <typeparam name="TValueNew">The type of the value of the resulting state object.</typeparam>
            <param name="obj">The self.</param>
            <param name="collector">A function selecting a second state object from the value of the first one.</param>
            <param name="resultSelector">A function to select the result of the above state objects.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="obj"/>, <paramref name="collector"/> or <paramref name="resultSelector"/> is <c>null</c>.
            </exception>
        </member>
        <member name="M:Interlook.Monads.State.GetResult``2(Interlook.Monads.State{``0,``1},``0)">
            <summary>
            Evaluates the state object and returns the result object.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="obj">The monadic state object.</param>
            <param name="state">The initial state to use.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj"/> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.State.GetResultLazy``2(Interlook.Monads.State{``0,``1},``0)">
            <summary>
            Lazily evaluates the state object and returns the result object.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="obj">The monadic state object.</param>
            <param name="state">The initial state to use.</param>
            <returns>A function that actually evaluates the state object.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj" /> was <c>null</c>.</exception>
        </member>
        <member name="T:Interlook.Monads.Try">
            <summary>
            Class with factory methods for <see cref="T:Interlook.Monads.Try`1"/>-Delegates
            </summary>
        </member>
        <member name="M:Interlook.Monads.Try.Bind``2(Interlook.Monads.Try{``0},System.Func{``0,Interlook.Monads.Try{``1}})">
            <summary>
            Binds the specified function to the try monad.
            The resulting instance depends to the return value
            of <paramref name="func"/> and if the function
            threw an exception, which would result in an <see cref="T:Interlook.Monads.Failure`1"/> instance.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.Try`1"/> monad.</param>
            <param name="func">The function to bind.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="obj"/> or <paramref name="func"/> was null.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Try.CombineWith``1(Interlook.Monads.Try{``0},Interlook.Monads.Try{``0},System.Func{``0,``0,``0})">
            <summary>
            Similar to <see cref="M:Interlook.Monads.Try.SelectMany``3(Interlook.Monads.Try{``0},System.Func{``0,Interlook.Monads.Try{``1}},System.Func{``0,``1,``2})"/>.
            Safely invokes the method calls of the current and the provided monad (in that order)
            and provides the return values of both to a combiner function. The result of
            that function will be returned.
            </summary>
            <typeparam name="T">Data type of the return value of both monads.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.Try`1"/>-monad.</param>
            <param name="other">Another (the second) <see cref="T:Interlook.Monads.Try`1"/>-monad.</param>
            <param name="combiner">A function, combining the return values of the first and the second monad, if both succeed.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Try.Invoke``1(System.Func{``0})">
            <summary>
            <para>
            Creates a <see cref="T:Interlook.Monads.Try`1"/>-instance, encapsulating a method invocation,
            which either returns a value of <c>TResult</c> or
            throws an exception.
            </para>
            </summary>
            <typeparam name="TResult">Data type of the result value.</typeparam>
            <param name="func">The method call to execute.</param>
            <returns>A <see cref="T:Interlook.Monads.Try`1"/>-instance.</returns>
        </member>
        <member name="M:Interlook.Monads.Try.MapTry``2(Interlook.Monads.Try{``0},System.Func{``0,``1},System.Func{System.Object,``1})">
            <summary>
            Evaluates the try monad with one of two given mapping functions
            depending on the state of the try.
            </summary>
            <typeparam name="TSource">Type of the result of <paramref name="obj"/>.</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="obj">A try monad.</param>
            <param name="successFunc">Function to be used for <see cref="T:Interlook.Monads.Success`1"/> instances.</param>
            <param name="failureFunc">Function to be used for <see cref="T:Interlook.Monads.Failure`1"/> instances.</param>
            <returns>The result of one of the specified functions, that was accordingly applied.</returns>
        </member>
        <member name="M:Interlook.Monads.Try.Select``2(Interlook.Monads.Try{``0},System.Func{``0,``1})">
            <summary>
            For LINQ support. Equal to <see cref="M:Interlook.Monads.Try.Then``2(Interlook.Monads.Try{``0},System.Func{``0,``1})"/>
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.Try`1"/> monad.</param>
            <param name="selector">Selector function, that shall be applied to the return value of the method call.</param>
            <returns>A <see cref="T:Interlook.Monads.Try`1"/>-monad, encapsulating the chained (still unexecuted) calls of both,
            the original method call and the selector function.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="obj"/> or <paramref name="selector"/> was null.
            </exception>
        </member>
        <member name="M:Interlook.Monads.Try.SelectMany``3(Interlook.Monads.Try{``0},System.Func{``0,Interlook.Monads.Try{``1}},System.Func{``0,``1,``2})">
            <summary>
            For LINQ Query Syntax support with multiple FROM clauses.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.Try`1"/>-monad.</param>
            <param name="func">A function to be bound in an additional <see cref="T:Interlook.Monads.Try`1"/>-monad.</param>
            <param name="selector">A selector function for the result of both functions.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Try.Then``2(Interlook.Monads.Try{``0},System.Func{``0,``1})">
            <summary>
            Chains two method calls.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.Try`1"/>-monad.</param>
            <param name="selector">Selector function, that shall be applied to
            the return value of the encapsulated method call.</param>
            <returns>
            A new <see cref="T:Interlook.Monads.Try`1"/>-monad, encapsulating the chained, but still
            not executed, calls of the monad's method and the selector function.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="obj"/> or <paramref name="selector"/> was null.
            </exception>
        </member>
        <member name="T:Interlook.Monads.Failure`1">
            <summary>
            A concrete <see cref="T:Interlook.Monads.Try`1"/> implementation
            for failed method invocations without valid
            results, but an error object.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <seealso cref="T:Interlook.Monads.Try`1" />
        </member>
        <member name="P:Interlook.Monads.Failure`1.Error">
            <summary>
            Returns the error object
            </summary>
        </member>
        <member name="P:Interlook.Monads.Failure`1.Failed">
            <summary>
            Returns, if the try was a failure
            </summary>
            <value>
            <c>true</c>, since this implementation represents failures.
            </value>
        </member>
        <member name="M:Interlook.Monads.Failure`1.#ctor(System.Object)">
            <summary>
            Creates a new <see cref="T:Interlook.Monads.Failure`1"/> instance
            </summary>
            <param name="error">The error object to assign to the instance. Must not be <c>null</c></param>
        </member>
        <member name="M:Interlook.Monads.Failure`1.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Interlook.Monads.Failure`1.GetHashCode">
            <summary>Returns a hash code for this instance.</summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Interlook.Monads.Failure`1.BindInternal``1(System.Func{`0,Interlook.Monads.Try{``0}})">
            <summary>
            Does not bind a function (since it's in failure state already)
            but returns another <see cref="T:Interlook.Monads.Failure`1"/> instance
            with the original error object.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <param name="func">Function to bind.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.Success`1">
            <summary>
            A concrete <see cref="T:Interlook.Monads.Try`1"/> implementation
            for successfull method results.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <seealso cref="T:Interlook.Monads.Try`1" />
        </member>
        <member name="P:Interlook.Monads.Success`1.Failed">
            <summary>
            Gets a value indicating whether the represented method
            call has failed.
            </summary>
            <value>
            <c>true</c> for the <see cref="T:Interlook.Monads.Success`1"/> implementation
            </value>
        </member>
        <member name="P:Interlook.Monads.Success`1.Value">
            <summary>
            Gets the actual result value.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Success`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Monads.Success`1"/> class,
            representing a successful method invocation
            </summary>
            <param name="value">The result value.</param>
        </member>
        <member name="M:Interlook.Monads.Success`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Success`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:Interlook.Monads.Success`1.BindInternal``1(System.Func{`0,Interlook.Monads.Try{``0}})">
            <summary>
            Binds a function to the internal state/value
            and returns a new <see cref="T:Interlook.Monads.Try`1"/> instance,\
            depending on the return value of <paramref name="func"/>
            and if it threw an exception.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <param name="func">Function to bind.</param>
            <returns>A new <see cref="T:Interlook.Monads.Success`1"/> instance for
            succeeded method calls; otherwise <see cref="T:Interlook.Monads.Failure`1"/>,
            if the function <paramref name="func"/> returned one or threw an exception</returns>
        </member>
        <member name="T:Interlook.Monads.Try`1">
            <summary>
            Abstract type for the try monad.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="P:Interlook.Monads.Try`1.Failed">
            <summary>
            Gets a value indicating whether the represented method
            call has failed.
            </summary>
            <value>
              <c>true</c> if invocation failed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Interlook.Monads.Try`1.BindInternal``1(System.Func{`0,Interlook.Monads.Try{``0}})">
            <summary>
            Binds in overriding classes a function to the internal state/value
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <param name="func">Function to bind.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.TryLazy`1">
            <summary>
            Implementation of the Try-Monad,
            which encapsulates a method/function-call.
            </summary>
            <typeparam name="T">Encapsulated data type.</typeparam>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.TryLazy">
            <summary>
            Class with factory methods for <see cref="T:Interlook.Monads.Try`1"/>-Delegates
            </summary>
        </member>
        <member name="M:Interlook.Monads.TryLazy.WrapCall``1(System.Func{``0})">
            <summary>
            <para>
            Creates a <see cref="T:Interlook.Monads.Try`1"/>-instance, encapsulating a method invocation,
            that either returns a value of <c>TResult</c> or
            throws an exception.
            </para>
            The method call itself will yet not be executed.
            </summary>
            <typeparam name="TResult">Data type of the result value.</typeparam>
            <param name="func">The method call to execute.</param>
            <returns>A <see cref="T:Interlook.Monads.Try`1"/>-instance.</returns>
        </member>
        <member name="M:Interlook.Monads.TryLazy.Invoke``1(Interlook.Monads.TryLazy{``0})">
            <summary>
            Safely executes the encapsulated method call.
            </summary>
            <typeparam name="TResult">Data type of the return value.</typeparam>
            <param name="obj">The <see cref="T:Interlook.Monads.Try`1"/>-monad, whose encapsulated call
            is to be executed.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.TryLazy.Memoize``1(Interlook.Monads.TryLazy{``0})">
            <summary>
            <para>
            Returns an <see cref="T:Interlook.Monads.TryLazy"/>-monad encapsulating
            all underlying lazy method calls, thus caching
            the result in a new lazy monad.
            </para>
            No instant evaluation or exceptions will occur.
            </summary>
            <typeparam name="TResult">Data type of the return value.</typeparam>
            <param name="obj">The <see cref="T:Interlook.Monads.TryLazy`1"/>-monad, whose encapsulated call
            is to be executed.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.TryLazy.Select``2(Interlook.Monads.TryLazy{``0},System.Func{``0,``1})">
            <summary>
            For LINQ support
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.TryLazy`1"/>-monad.</param>
            <param name="selector">Selector function, that shall be applied to the return value of the method call.</param>
            <returns>A <see cref="T:Interlook.Monads.TryLazy`1"/>-monad, encapsulating the chained (still unexecuted) calls of both,
            the original method call and the selector function.</returns>
        </member>
        <member name="M:Interlook.Monads.TryLazy.SelectMany``3(Interlook.Monads.TryLazy{``0},System.Func{``0,Interlook.Monads.TryLazy{``1}},System.Func{``0,``1,``2})">
            <summary>
            For LINQ Query Syntax support with multiple FROM clauses.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.TryLazy`1"/>-monad.</param>
            <param name="func">A function to be bound in an additional <see cref="T:Interlook.Monads.TryLazy`1"/>-monad.</param>
            <param name="selector">A selector function for the result of both functions.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.TryLazy.Then``2(Interlook.Monads.TryLazy{``0},System.Func{``0,``1})">
            <summary>
            Chains two method calls.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.TryLazy`1"/>-monad.</param>
            <param name="selector">Selector function, that shall be applied to
            the return value of the encapsulated method call.</param>
            <returns>
            A new <see cref="T:Interlook.Monads.TryLazy`1"/>-monad, encapsulating the chained, but still
            not executed, calls of the monad's method and the selector function.
            </returns>
        </member>
        <member name="M:Interlook.Monads.TryLazy.Bind``2(Interlook.Monads.TryLazy{``0},System.Func{``0,Interlook.Monads.Try{``1}})">
            <summary>
            Binds the specified function to the try monad.
            The resulting instance depends to the return value
            of <paramref name="func"/> and if the function
            threw an exception, which would result in an <see cref="T:Interlook.Monads.Failure`1"/> instance.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.Try`1"/> monad.</param>
            <param name="func">The function to bind.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="obj"/> or <paramref name="func"/> was null.
            </exception>
        </member>
        <member name="M:Interlook.Monads.TryLazy.Bind``2(Interlook.Monads.TryLazy{``0},System.Func{``0,Interlook.Monads.TryLazy{``1}})">
            <summary>
            Binds the specified function to the try monad.
            The resulting instance depends to the return value
            of <paramref name="func"/> and if the function
            threw an exception, which would result in an <see cref="T:Interlook.Monads.Failure`1"/> instance.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.Try`1"/> monad.</param>
            <param name="func">The function to bind.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="obj"/> or <paramref name="func"/> was null.
            </exception>
        </member>
        <member name="M:Interlook.Monads.TryLazy.MapTry``2(Interlook.Monads.TryLazy{``0},System.Func{``0,``1},System.Func{System.Object,``1})">
            <summary>
            Evaluates the try monad with one of two given mapping functions
            depending on the state of the try.
            </summary>
            <typeparam name="TSource">Type of the result of <paramref name="obj"/>.</typeparam>
            <typeparam name="TResult">Type of the result.</typeparam>
            <param name="obj">A try monad.</param>
            <param name="successFunc">Function to be used for <see cref="T:Interlook.Monads.Success`1"/> instances.</param>
            <param name="failureFunc">Function to be used for <see cref="T:Interlook.Monads.Failure`1"/> instances.</param>
            <returns>The result of one of the specified functions, that was accordingly applied.</returns>
        </member>
        <member name="M:Interlook.Monads.TryLazy.CombineWith``1(Interlook.Monads.TryLazy{``0},Interlook.Monads.TryLazy{``0},System.Func{``0,``0,``0})">
            <summary>
            Similar to <see cref="M:Interlook.Monads.TryLazy.SelectMany``3(Interlook.Monads.TryLazy{``0},System.Func{``0,Interlook.Monads.TryLazy{``1}},System.Func{``0,``1,``2})"/>.
            Safely invokes the method calls of the current and the provided monad (in that order)
            and provides the return values of both to a combiner function. The result of
            that function will be returned.
            </summary>
            <typeparam name="T">Data type of the return value of both monads.</typeparam>
            <param name="obj">A <see cref="T:Interlook.Monads.TryLazy`1"/>-monad.</param>
            <param name="other">Another (the second) <see cref="T:Interlook.Monads.TryLazy`1"/>-monad.</param>
            <param name="combiner">A function, combining the return values of the first and the second monad, if both succeed.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Monads.Unit">
            <summary>
            A type with only one single value.
            Is used in monads instead of <c>void</c>.
            </summary>
        </member>
        <member name="P:Interlook.Monads.Unit.Default">
            <summary>
            Gets the very single value.
            </summary>
        </member>
        <member name="M:Interlook.Monads.Unit.Return(System.Action)">
            <summary>
            Returns the <see cref="T:Interlook.Monads.Unit"/> type/instance after invoking an action
            to simulate a call of a <c>void</c> method.
            </summary>
            <param name="action">The action to perform.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> was <c>null</c>.</exception>
        </member>
        <member name="T:Interlook.Monads.Writer`2">
            <summary>
            Represents a monadic writer.
            This monad is innately lazy.
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="T:Interlook.Monads.WriterEntry`2">
            <summary>
            The result value of the writer monad
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="P:Interlook.Monads.WriterEntry`2.Value">
            <summary>
            Gets the current value.
            </summary>
        </member>
        <member name="P:Interlook.Monads.WriterEntry`2.Elements">
            <summary>
            Gets the elements, written so far.
            </summary>
        </member>
        <member name="M:Interlook.Monads.WriterEntry`2.#ctor(`1,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Interlook.Monads.WriterEntry`2" /> class.
            </summary>
            <param name="value">The value.</param>
            <param name="output">The output to be written. Defaults to empty if <c>null</c>.</param>
        </member>
        <member name="T:Interlook.Monads.Writer">
            <summary>
            Extension methods for writer monad
            </summary>
        </member>
        <member name="M:Interlook.Monads.Writer.ReturnWriter``2(``1)">
            <summary>
            Returns a new, empty monadic writer with the specified value.
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Writer.Tell``2(``1,``0)">
            <summary>
            Writes an elements into a new writer with a specified value.
            </summary>
            <typeparam name="TCollection">The type of the collection.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="value">The value.</param>
            <param name="elementToWrite">The element to write.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Writer.Tell``2(``1,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes elements into a new writer with a specified value.
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="value">The value.</param>
            <param name="elements">The elements.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">elements</exception>
        </member>
        <member name="M:Interlook.Monads.Writer.Tell``1(``0)">
            <summary>
            Writes an element into a writer without a value.
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <param name="elementToWrite">The element to write.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Monads.Writer.Map``3(Interlook.Monads.Writer{``0,``1},System.Func{``1,``2})">
            <summary>
            Maps a writer to a new writer.
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TValueNew">The type of the new value.</typeparam>
            <param name="obj">The object.</param>
            <param name="function">The function, that selects a type <typeparamref name="TValueNew" />
            from type <typeparamref name="TValue" /></param>
            <returns>
            A new <see cref="T:Interlook.Monads.Writer`2" /> instance.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj" /> or <paramref name="function" /> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.Writer.Select``3(Interlook.Monads.Writer{``0,``1},System.Func{``1,``2})">
            <summary>
            For LINQ support. Just calls <see cref="M:Interlook.Monads.Writer.Map``3(Interlook.Monads.Writer{``0,``1},System.Func{``1,``2})"/>
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TValueNew">The type of the new value.</typeparam>
            <param name="obj">The object.</param>
            <param name="function">The function, that selects a type <typeparamref name="TValueNew" />
            from type <typeparamref name="TValue" /></param>
            <returns>
            A new <see cref="T:Interlook.Monads.Writer`2" /> instance.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj" /> or <paramref name="function" /> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.Writer.Bind``3(Interlook.Monads.Writer{``0,``1},System.Func{``1,Interlook.Monads.Writer{``0,``2}})">
            <summary>
            Binds a function to a monadic writer.
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TValueNew">The type of the new value.</typeparam>
            <param name="obj">The object.</param>
            <param name="function">The function, that selects a type <typeparamref name="TValueNew" />
            from type <typeparamref name="TValue" /></param>
            <returns>
            A new <see cref="T:Interlook.Monads.Writer`2" /> instance.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj" /> or <paramref name="function" /> was <c>null</c>.</exception>
        </member>
        <member name="M:Interlook.Monads.Writer.SelectMany``4(Interlook.Monads.Writer{``0,``1},System.Func{``1,Interlook.Monads.Writer{``0,``2}},System.Func{``1,``2,``3})">
            <summary>
            For LINQ support.
            </summary>
            <typeparam name="TCollection">The type of the elements to be written.</typeparam>
            <typeparam name="TValue">The type of the value of the first writer.</typeparam>
            <typeparam name="TSelect">The type of the value of the second writer.</typeparam>
            <typeparam name="TValueNew">The type of the new value.</typeparam>
            <param name="obj">The object.</param>
            <param name="functionToBind">A function, selecting a new Writer from the value of <paramref name="obj" /></param>
            <param name="resultSelector">A function, selecting the result of the values of the two writer monad objects.</param>
            <returns>
            A new <see cref="T:Interlook.Monads.Writer`2" /> instance.
            </returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="obj" /> or <paramref name="resultSelector" /> was <c>null</c>.</exception>
        </member>
        <member name="T:Interlook.Security.StringEncryptionExt">
            <summary>
            Helper Methods for string encryptions
            </summary>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.ComputeHashString(System.String,System.Text.Encoding,System.Security.Cryptography.HashAlgorithm,System.String)">
            <summary>
            Computes the hash of the string using a specific hash algorithm.
            </summary>
            <param name="stringToHash">The string to calculate the hash code for.</param>
            <param name="encoding">The character encoding used by the given string.</param>
            <param name="algorithm">The algorithm to use fpr calculating the hash.</param>
            <param name="salt">A trailing salt string, appended before hashing (optional, may be <c>null</c>).</param>
            <returns>The string representation of the computed hash for the given string. Any possible hyphens are trimmed.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.DecryptStringForMachine(System.String)">
            <summary>
            Decrypts a string that has been encrypted with <see cref="M:Interlook.Security.StringEncryptionExt.EncryptStringForMachine(System.String)"/>
            using the Windows DPAPI on the same machine.
            </summary>
            <param name="encryptedString">The <c>Base64</c>-representation of cipher data
            created using <see cref="M:Interlook.Security.StringEncryptionExt.EncryptStringForMachine(System.String)"/>.</param>
            <returns>The decrypted plaintext.</returns>
            <remarks>
            Decryption will fail, if the cipher data has been created within another windows context/machine.
            </remarks>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.DecryptStringForUser(System.String)">
            <summary>
            Decrypts a string that has been encrypted with <see cref="M:Interlook.Security.StringEncryptionExt.EncryptStringForUser(System.String)"/>
            using the Windows DPAPI for the same user.
            </summary>
            <param name="encryptedString">The <c>Base64</c>-representation of cipher data
            created using <see cref="M:Interlook.Security.StringEncryptionExt.EncryptStringForUser(System.String)"/>.</param>
            <returns>The decrypted plaintext.</returns>
            <remarks>
            Decryption will fail, if the cipher data has been created within another windows user context.
            </remarks>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.DecryptStringWith(System.Byte[],System.Security.SecureString,System.Text.Encoding)">
            <summary>
            Decrypts the given binary data with AES256 into a string using given character encoding
            and the default initialization vector.
            </summary>
            <param name="cipherData">Binary cipher data.</param>
            <param name="passPhrase">The encryption keyphrase.</param>
            <param name="encoding">Character encoding to use.</param>
            <returns>
            A <see cref="T:System.String"/>, containing the original text, that has been encrypted.
            </returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.DecryptStringWith(System.Byte[],System.Security.SecureString,System.Byte[],System.Text.Encoding)">
            <summary>
            Decrypts the given binary data with AES256 into a string using given character encoding
            and a given initialization vector.
            </summary>
            <param name="cipherData">Binary cipher data.</param>
            <param name="passPhrase">The encryption keyphrase.</param>
            <param name="iv">Blockcipher initialization vector to use.</param>
            <param name="encoding">Character encoding to use.</param>
            <returns>
            A <see cref="T:System.String"/>, containing the original text, that has been encrypted.
            </returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.EncryptStringForMachine(System.String)">
            <summary>
            Encrypts the string using Windows DPAPI for the context of the local machine.
            </summary>
            <param name="value">The plaintext to encrypt.</param>
            <returns>A <see cref="T:System.String"/> with the <c>Base64</c> representation of the cipher data.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.EncryptStringForUser(System.String)">
            <summary>
            Encrypts the string using Windows DPAPI for the context of the current user.
            </summary>
            <param name="value">The plaintext to encrypt.</param>
            <returns>A <see cref="T:System.String"/> with the <c>Base64</c> representation of the cipher data.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.EncryptStringWith(System.String,System.Security.SecureString,System.Byte[])">
            <summary>
            Encrypts a string using AES256
            </summary>
            <param name="plainText">String to encrypt.</param>
            <param name="passPhrase">The encryption keyphrase.</param>
            <param name="iv">Blockcipher initialization vector to use.</param>
            <returns>A byte-array with cipher data.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.EncryptStringWith(System.String,System.Security.SecureString)">
            <summary>
            Encrypts a string using AES256 and the default initialization vector.
            </summary>
            <param name="plainText">String to encrypt.</param>
            <param name="passPhrase">The encryption keyphrase.</param>
            <returns>A byte-array with cipher data.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetMD5(System.String,System.String)">
            <summary>
            Computes the MD5 hash of a string.
            </summary>
            <param name="stringToHash">string to hash.</param>
            <param name="salt">Optional salt.</param>
            <returns>The string representation of the computed MD5 hash for the given string.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetMD5(System.String,System.Text.Encoding,System.String)">
            <summary>
            Computes the MD5 hash of a string.
            </summary>
            <param name="stringToHash">string to hash.</param>
            <param name="encoding">The encoding to use.</param>
            <param name="salt">Optional salt.</param>
            <returns>
            The string representation of the computed MD5 hash for the given string.
            </returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetSHA1(System.String,System.String)">
            <summary>
            Computes the SHA1 hash of a string.
            </summary>
            <param name="stringToHash">The string to calculate the hash code for.</param>
            <param name="salt">A trailing salt string, appended before hashing (optional, may be <c>null</c>).</param>
            <returns>The string representation of the computed SHA1 hash for the given string.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetSHA1(System.String,System.Text.Encoding,System.String)">
            <summary>
            Computes the SHA1 hash of a string.
            </summary>
            <param name="stringToHash">The string to calculate the hash code for.</param>
            <param name="encoding">The character encoding used by the given string.</param>
            <param name="salt">A trailing salt string, appended before hashing (optional, may be <c>null</c>).</param>
            <returns>The string representation of the computed SHA1 hash for the given string.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetSHA256(System.String,System.String)">
            <summary>
            Computes the SHA256 hash of a string.
            </summary>
            <param name="stringToHash">The string to calculate the hash code for.</param>
            <param name="salt">A trailing salt string, appended before hashing (optional, may be <c>null</c>).</param>
            <returns>The string representation of the computed SHA256 hash for the given string.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetSHA256(System.String,System.Text.Encoding,System.String)">
            <summary>
            Computes the SHA256 hash of a string.
            </summary>
            <param name="stringToHash">The string to calculate the hash code for.</param>
            <param name="encoding">The character encoding used by the given string.</param>
            <param name="salt">A trailing salt string, appended before hashing (optional, may be <c>null</c>).</param>
            <returns>The string representation of the computed SHA256 hash for the given string.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetSHA512(System.String,System.String)">
            <summary>
            Computes the SHA512 hash of a string.
            </summary>
            <param name="stringToHash">The string to calculate the hash code for.</param>
            <param name="salt">A trailing salt string, appended before hashing (optional, may be <c>null</c>).</param>
            <returns>The string representation of the computed SHA512 hash for the given string.</returns>
        </member>
        <member name="M:Interlook.Security.StringEncryptionExt.GetSHA512(System.String,System.Text.Encoding,System.String)">
            <summary>
            Computes the SHA512 hash of a string.
            </summary>
            <param name="stringToHash">The string to calculate the hash code for.</param>
            <param name="encoding">The character encoding used by the given string.</param>
            <param name="salt">A trailing salt string, appended before hashing (optional, may be <c>null</c>).</param>
            <returns>The string representation of the computed SHA512 hash for the given string.</returns>
        </member>
        <member name="T:Interlook.Text.ExceptionExtensions">
            <summary>
            Extension methods for exceptions.
            </summary>
        </member>
        <member name="M:Interlook.Text.ExceptionExtensions.ToCompleteString(System.Exception)">
            <summary>
            Returns the complete, aggregated string representation of the exception
            including nested inner exceptions up to a recursion depth of 10.
            </summary>
            <param name="ex">The exception.</param>
            <returns></returns>
        </member>
        <member name="M:Interlook.Text.ExceptionExtensions.ToCompleteString(System.Exception,System.Int32)">
            <summary>
            Returns the complete, aggregated string representation of the exception
            including nested inner exceptions up to an given maximum depth.
            </summary>
            <param name="ex">The exception.</param>
            <param name="maxDepth">The maximum depth.</param>
            <returns></returns>
        </member>
        <member name="T:Interlook.Text.MultiString">
            <summary>
            Class for strings, that may contain additional alternative strings, to
            extend the actual content.
            </summary>
            <remarks>
            Appended strings may be seen as kind of optional extension of the main content,
            as like translations, captions, remarks, categories etc.
            </remarks>
        </member>
        <member name="P:Interlook.Text.MultiString.Content">
            <summary>
            Main/default content of the string
            </summary>
        </member>
        <member name="P:Interlook.Text.MultiString.Item(System.String)">
            <summary>
            Set or gets an additional/alternative content string.
            </summary>
            <param name="indexer">Name/identifier of the additional string or <c>null</c> or an empty string for the main string.</param>
        </member>
        <member name="M:Interlook.Text.MultiString.#ctor">
            <summary>
            Creates a new <see cref="T:Interlook.Text.MultiString"/> instance.
            </summary>
        </member>
        <member name="M:Interlook.Text.MultiString.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Interlook.Text.MultiString"/> instance with initial content.
            </summary>
            <param name="content">Content of the Multistring.</param>
        </member>
        <member name="T:Interlook.Text.StringExtensions">
            <summary>
            A helper class providing methods for checking and manipulating string objects.
            </summary>
        </member>
        <member name="M:Interlook.Text.StringExtensions.AintNullNorEmpty(System.String)">
            <summary>
            Indicates whether the string is neither <c>null</c> nor an empty string.
            </summary>
            <param name="str">The string to test.</param>
            <returns><c>true</c> if the given string actually contains characters. Otherwise, if it's empty or even <c>null</c>, <c>false</c> is returned.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.CapitalizedFirstCharacter(System.String,System.Boolean)">
            <summary>
            Returns a string, that always begins with a capital letter.
            </summary>
            <param name="str">String, where first letter must be capital.</param>
            <param name="forceLowercaseRemainder">If <c>true</c>, all characters following the first are guaranteed to be lower case, otherwise left untouched.</param>
            <returns>A string with a guaranteed upper case first character.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Ensure(System.String)">
            <summary>
            Ensures, that the corresponding string object is no <c>null</c>-reference.
            </summary>
            <param name="str">The string to test.</param>
            <returns>The given string itself, if it was not <c>null</c>, otherwise an empty string is returned.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.IsNothing(System.String)">
            <summary>
            Checks if a string is <c>null</c>, empty or just
            contains whitespace characters.
            </summary>
            <param name="str">String object to check.</param>
        </member>
        <member name="M:Interlook.Text.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>
            Indicates whether the string is <c>null</c> or an empty string.
            </summary>
            <param name="str">The string to test.</param>
            <returns><c>true</c> if the given string is <c>null</c> or an empty string. Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.IsNumericOnly(System.String)">
            <summary>
            Indicates whether the string only contains decimal numbers.
            </summary>
            <param name="str">The string to test.</param>
            <returns><c>true</c> if the given string only contains decimal numbers.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.IsNumericOnly(System.String,System.String)">
            <summary>
            Indicates whether the string only contains decimal numbers or special additional characters.
            </summary>
            <param name="str">The string to test.</param>
            <param name="acceptedAdditionalChars">A string, containing additional accepted characters.</param>
            <returns><c>true</c> if the given string only contains decimal numbers or the provided additional characters.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.IsNumericOnly(System.String,System.Char[])">
            <summary>
            Indicates whether the string only contains decimal numbers or special additional characters.
            </summary>
            <param name="str">The string to test.</param>
            <param name="acceptedAdditionalChars">An array of additional accepted characters.</param>
            <returns><c>true</c> if the given string only contains decimal numbers or the provided additional characters.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Left(System.String,System.Int32)">
            <summary>
            Returns the first <c>n</c> characters of a string.
            </summary>
            <param name="str">The string.</param>
            <param name="length">The maximum number of characters to return.</param>
            <returns>A <see cref="T:System.String"/>, containing at most the requested number oft characters
            from the beginning of the given string.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Left(System.String,System.Int32,System.Boolean)">
            <summary>
            Returns the first <c>n</c> characters of a string.
            </summary>
            <param name="str">The string.</param>
            <param name="length">The maximum number of characters to return.</param>
            <param name="strict">if set to <c>true</c> an exception is thrown if <c>length</c>
            exceeds the length of the given string. Otherwise behavior is equal to <see cref="M:Interlook.Text.StringExtensions.Left(System.String,System.Int32)"/></param>
            <returns>
            A <see cref="T:System.String" />, containing at most the requested number oft characters
            from the beginning of the given string.
            </returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Limit(System.String,System.Int32)">
            <summary>
            Limits a string to a specific length.
            </summary>
            <param name="str">String to limit in length.</param>
            <param name="maxLength">Maximum length of the string.</param>
            <returns>
            A <see cref="T:System.String"/>, whose length never exceeds given <c>maxLength</c>.
            </returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.MatchesRegEx(System.String,System.String)">
            <summary>
            Checks if a string matches a regular expression.
            </summary>
            <param name="value">The string value to check.</param>
            <param name="pattern">The regular expression pattern for checking.</param>
        </member>
        <member name="M:Interlook.Text.StringExtensions.NormalizeLatinChars(System.String)">
            <summary>
            Returns a normalized copy of a string, meaning only capitals without any accent signs (e.g. accent circumflex).
            </summary>
            <param name="str">The string to normalize.</param>
            <returns>A capitalized string that represents the provided string in a way to be comparable case- and accent-insensitive.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Otherwise(System.String,System.String)">
            <summary>
            Returns an alternative string, if this instance is <c>null</c> or empty.
            </summary>
            <param name="str">The string to check.</param>
            <param name="alternativeString">Alternative string, if the original was empty or <c>null</c>.</param>
            <returns>The original string or, if it was <c>null</c> or empty, the alternative string.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Otherwise(System.String,System.Func{System.String,System.Boolean},System.String)">
            <summary>
            Returns an alternative string, if this instance satisfies a given condition.
            </summary>
            <param name="str">The string to check.</param>
            <param name="predicate">The condition, that has to be true to use <paramref name="alternativeString"/>.</param>
            <param name="alternativeString">Alternative string, if the original satisfied the condition.</param>
            <returns>
            The original string or, if it satisfied the condition, the alternative string.
            </returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Otherwise(System.String,System.Func{System.String,System.Boolean},System.Func{System.String,System.String})">
            <summary>
            Returns an alternative string, if this instance satisfies a given condition.
            </summary>
            <param name="str">The string to check.</param>
            <param name="predicate">The condition, that has to be true to use <paramref name="alternativeStringFactory"/>.</param>
            <param name="alternativeStringFactory">A function, getting the current string to create the alternative string.</param>
            <returns>
            The original string or, if it satisfied the condition, the alternative string.
            </returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.ParseDoubleOrDefault(System.String)">
            <summary>
            Parses a string into  <see cref="T:System.Double"/>
            or returns <c>0.0</c>, if an error occured.
            </summary>
            <param name="str">String to parse.</param>
            <returns>Converted  <see cref="T:System.Double"/> value or <c>0</c>.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.ParseIntOrDefault(System.String)">
            <summary>
            Parses a string into <see cref="T:System.Int32"/>
            or returns <c>0.0</c>, if an error occured.
            </summary>
            <param name="str">String to parse.</param>
            <returns>Converted  <see cref="T:System.Int32"/> value or <c>0</c>.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.ParseLongOrDefault(System.String)">
            <summary>
            Parses a string into <see cref="T:System.Int64"/>
            or returns <c>0.0</c>, if an error occured.
            </summary>
            <param name="str">String to parse.</param>
            <returns>Converted  <see cref="T:System.Int64"/> value or <c>0</c>.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.ParseShortOrDefault(System.String)">
            <summary>
            Parses a string into <see cref="T:System.Int16"/>
            or returns <c>0.0</c>, if an error occured.
            </summary>
            <param name="str">String to parse.</param>
            <returns>Converted  <see cref="T:System.Int16"/> value or <c>0</c>.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.ParseTimeSpanOrDefault(System.String)">
            <summary>
            Parses a string into <see cref="T:System.TimeSpan"/>
            or returns <c>0</c> seconds, if an error occured.
            </summary>
            <param name="str">String to parse.</param>
            <returns>Converted <see cref="T:System.TimeSpan"/> value or <c>0</c> seconds.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Right(System.String,System.Int32)">
            <summary>
            Returns the last <c>n</c> characters of a string.
            </summary>
            <param name="str">The string.</param>
            <param name="length">The maximum number of characters to return.</param>
            <returns>A <see cref="T:System.String"/>, containing at most the requested number oft characters
            from the end of the given string.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Right(System.String,System.Int32,System.Boolean)">
            <summary>
            Returns the last <c>n</c> characters of a string.
            </summary>
            <param name="str">The string.</param>
            <param name="length">The maximum number of characters to return.</param>
            <param name="strict">if set to <c>true</c> an exception is thrown if <c>length</c>
            exceeds the length of the given string. Otherwise behavior is equal to <see cref="M:Interlook.Text.StringExtensions.Right(System.String,System.Int32)"/></param>
            <returns>
            A <see cref="T:System.String" />, containing at most the requested number oft characters
            from the end of the given string.
            </returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.SecureEquals(System.String,System.String)">
            <summary>
            Compares a string to another, by trying to achieve an almost constant time,
            to prevent side channel attacks (timing attacks)
            </summary>
            <param name="original">The original string</param>
            <param name="candidate">The string to compare to</param>
            <returns><c>true</c> if the two strings match exactly (so even case sensitive), otherwise <c>false</c></returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.SecureEquals(System.Char[],System.Char[])">
            <summary>
            Compares an array of characters to another, by trying to achieve an almost constant time,
            to mitigate side channel attacks (timing attacks)
            </summary>
            <param name="original">The original characters.</param>
            <param name="candidate">The char array to compare.</param>
            <returns><c>true</c> if the two arrays match exactly (so even case sensitive), otherwise <c>false</c></returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.Skip(System.String,System.Int32)">
            <summary>
            Skips <c>n</c> characters of the string an returns the remainder.
            </summary>
            <param name="str">The string.</param>
            <param name="length">Number of characters to skip.</param>
            <returns>The remainder of the string, which may be empty,
            if the original string was shorter than <c>n</c>.</returns>
        </member>
        <member name="M:Interlook.Text.StringExtensions.TrimProtected(System.String)">
            <summary>
            Removes all leading and trailing white-space characters from a string object, that even may be <c>null</c>.
            </summary>
            <param name="str">The string object to trim safely (may be null).</param>
            <returns>A trimmed copy of the provided string or an empty string, if the parameter string was <c>null</c>.
            Is never <c>null</c></returns>
        </member>
        <member name="T:System.Collections.Generic.DictionaryExtensions">
            <summary>
            Helper methods for generic dictionaries
            </summary>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value associated with the specified key of a dictionary 
            or a default value, if the dictionary does not contain the key.
            </summary>
            <typeparam name="TKey">Type of the keys of the dictionary.</typeparam>
            <typeparam name="TValue">Type of the values of the dictionary.</typeparam>
            <param name="dictionary">A dictionary.</param>
            <param name="key">The key of the value to get.</param>
            <param name="defaultValue">The default value to be returned, of the key was not found.</param>
            <returns>
            The value associated with the specified key, if that key was found in the dictionary;
            in all other cases <paramref name="defaultValue"/>.
            </returns>
            <remarks>
            This method does not throw <see cref="T:System.NullReferenceException"/>, it returns
            the value of <paramref name="defaultValue"/> instead.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets the value associated with the specified key of a dictionary 
            or a default value, if the dictionary does not contain the key.
            </summary>
            <typeparam name="TKey">Type of the keys of the dictionary.</typeparam>
            <typeparam name="TValue">Type of the values of the dictionary.</typeparam>
            <param name="dictionary">A dictionary.</param>
            <param name="key">The key of the value to get.</param>
            <returns>
            The value associated with the specified key, if that key was found in the dictionary;
            in all other cases the default value of the type <typeparamref name="TValue"/>.
            </returns>
            <remarks>
            This method does not throw <see cref="T:System.NullReferenceException"/>, it returns
            the default value of <typeparamref name="TValue"/> instead.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.GetValueMaybe``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets the value associated with the specified key of a dictionary
            as a <see cref="T:Interlook.Monads.Maybe`1"/> instance.
            </summary>
            <typeparam name="TKey">Type of the keys of the dictionary.</typeparam>
            <typeparam name="TValue">Type of the values of the dictionary.</typeparam>
            <param name="dictionary">A dictionary.</param>
            <param name="key">The key of the value to get.</param>
            <returns>
            A <see cref="T:Interlook.Monads.Maybe`1"/> instance, containing the associated value as <see cref="T:Interlook.Monads.Just`1"/>,
            if the key was found in the dictionary; in all other cases <see cref="T:Interlook.Monads.Nothing`1"/>
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.AddIf``2(System.Collections.Generic.IDictionary{``0,``1},System.Boolean,``0,``1)">
            <summary>
            Adds a value to a dictionary, if a specified condition is met.
            </summary>
            <typeparam name="TKey">Type of the keys of the dictionary.</typeparam>
            <typeparam name="TValue">Type of the values of the dictionary.</typeparam>
            <param name="dictionary">A dictionary.</param>
            <param name="key">The key of the value to get.</param>
            <param name="value">The new value to add.</param>
            <param name="condition">The condition, which specifies, if the value shall actually be added.</param>
            <returns>The original dictionary or a new, possibly empty, one (Fluent API). Never <c>null</c>.</returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryExtensions.AddIf``2(System.Collections.Generic.IDictionary{``0,``1},System.Boolean,System.Func{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Adds a value to a dictionary, if a specified condition is met.
            </summary>
            <typeparam name="TKey">Type of the keys of the dictionary.</typeparam>
            <typeparam name="TValue">Type of the values of the dictionary.</typeparam>
            <param name="dictionary">A dictionary.</param>
            <param name="newValueFactory">Factory method for the new <see cref="T:System.Collections.Generic.KeyValuePair`2"/> instance. Executed not before <paramref name="condition"/> has been successfully checked.</param>
            <param name="condition">The condition, which specifies, if the value shall actually be added.</param>
            <returns>The original dictionary or a new, possibly empty, one (Fluent API). Never <c>null</c>.</returns>
        </member>
        <member name="T:System.Linq.EnumerationExtensions">
            <summary>
            Contains helper methods for enumerators and LINQ2Objects
            </summary>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.AnyProtected``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines, if a sequence contains any elements WITHOUT
            throwing a <see cref="T:System.ArgumentNullException"/>, if <paramref name="source"/> was <c>null</c>.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The sequencde to check for emptiness.</param>
            <returns><c>false</c>, if <paramref name="source"/> is empty or <c>null</c>, otherwise <c>true</c>.</returns>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.AnyProtected``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines, if a sequence contains any elements, with satisfy a condition.
            Does NOT THROW <see cref="T:System.ArgumentNullException"/>, if <paramref name="source"/> was <c>null</c>.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The sequencde to check for emptiness.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns><c>false</c>, if <paramref name="source"/> is <c>null</c> or contains no elements,
            which did not pass the test in the specified predicate; otherwise <c>true</c>.</returns>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.AppendIf``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,``0)">
            <summary>
            Appends a value to the end of the sequence. if a specified condition is met.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="condition">The predicate, which constraints the appending of the new element.</param>
            <param name="newElement">The value to append to <paramref name="source"/>.</param>
            <returns>A new Sequence that ends with <paramref name="newElement"/>.
            Is never <c>null</c>.</returns>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.AppendIf``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Func{``0})">
            <summary>
            Appends a value to the end of the sequence. if a specified condition is met.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="condition">The predicate, which constraints the appending of the new element.</param>
            <param name="newElementFactory">The factory method, executed if the specified constraint in <paramref name="condition"/> is met,
            which creates a value to append to <paramref name="source"/>.</param>
            <returns>A new Sequence that ends with the new value created by <paramref name="newElementFactory"/>.
            Is never <c>null</c>.</returns>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.AsEnumerable``1(``0)">
            <summary>
            Returns a new Sequence containing the value.
            </summary>
            <typeparam name="T">The type of the elements of the new sequence.</typeparam>
            <param name="obj">The object to be added to the new sequence.</param>
            <returns>A new <see cref="T:System.Collections.Generic.IEnumerable`1"/> sequence containing <paramref name="obj"/>.</returns>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            <para>
            Iterates a sequence like the <c>foreach</c> statement
            and executes <paramref name="action"/> for every element.
            </para>
            <para>This <c>foreach</c>-overload does NOT support a <c>break</c>-mechanism.</para>
            </summary>
            <typeparam name="T">The type of the elements of the new sequence.</typeparam>
            <param name="source">The sequence to iterate.</param>
            <param name="action">The Action to be executed for every element.</param>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            <para>
            Iterates a sequence like the <c>foreach</c> statement
            and executes <paramref name="action"/> for every element.
            </para>
            <para>This <c>foreach</c>-overload does NOT support a <c>break</c>-mechanism.</para>
            </summary>
            <typeparam name="T">The type of the elements of the new sequence.</typeparam>
            <param name="source">The sequence to iterate.</param>
            <param name="action">The Action to be executed for every element. 
            The second parameter represents the zero-based index of the source element.</param>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32,System.Linq.EnumerationExtensions.CancelProc})">
            <summary>
            <para>
            Iterates a sequence like the <c>foreach</c> statement
            and executes <paramref name="action"/> for every element.
            </para>
            <para>This <c>foreach</c>-overload supports a <c>break</c>-mechanism.</para>
            </summary>
            <typeparam name="T">The type of the elements of the new sequence.</typeparam>
            <param name="source">The sequence to iterate.</param>
            <param name="action">The Action to be executed for every element. 
            The second parameter represents the zero-based index of the source element.
            The third parameter is an instance of <see cref="T:System.Linq.EnumerationExtensions.CancelProc"/>, which simulates
            the <c>break</c> statement of a <c>foreach</c>-loop.</param>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            <para>
            Iterates a sequence like the <c>foreach</c> statement
            and executes <paramref name="action"/> for every element.
            </para>
            <para>This <c>foreach</c>-overload supports a <c>break</c>-mechanism.</para>
            </summary>
            <typeparam name="T">The type of the elements of the new sequence.</typeparam>
            <param name="source">The sequence to iterate.</param>
            <param name="action">The Action to be executed for every element. 
            The second parameter represents the zero-based index of the source element.</param>
            <param name="cancelingPredicate">A function, that is used as break-condition BEFORE every iteration.</param>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.PrependIf``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,``0)">
            <summary>
            Adds a value to the beginning of the sequence. if a specified condition is met.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="condition">The predicate, which constraints the appending of the new element.</param>
            <param name="newElement">The value to add to the beginning of <paramref name="source"/>.</param>
            <returns>A new Sequence that begins with <paramref name="newElement"/>.
            Is never <c>null</c>.</returns>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.PrependIf``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Func{``0})">
            <summary>
            Adds a value to the beginning of the sequence. if a specified condition is met.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="condition">The predicate, which constraints the appending of the new element.</param>
            <param name="newElementFactory">The factory method, executed if the specified constraint in <paramref name="condition"/> is met,
            which creates a value to add to the beginning of <paramref name="source"/>.</param>
            <returns>A new Sequence that begins with the new value created by <paramref name="newElementFactory"/>.
            Is never <c>null</c>.</returns>
        </member>
        <member name="T:System.Linq.EnumerationExtensions.CancelProc">
            <summary>
            Helper flag for break support in <see cref="M:System.Linq.EnumerationExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32,System.Linq.EnumerationExtensions.CancelProc})"/>
            </summary>
        </member>
        <member name="P:System.Linq.EnumerationExtensions.CancelProc.CancelRequested">
            <summary>
            Determines, if the current iteration is to be canceled
            </summary>
        </member>
        <member name="M:System.Linq.EnumerationExtensions.CancelProc.Cancel">
            <summary>
            Requests to cancel the iteration by setting <see cref="P:System.Linq.EnumerationExtensions.CancelProc.CancelRequested"/> to <c>true</c>.
            </summary>
        </member>
    </members>
</doc>
